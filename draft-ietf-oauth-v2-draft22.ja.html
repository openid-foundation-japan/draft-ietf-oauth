<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>The OAuth 2.0 Authorization Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="The OAuth 2.0 Authorization Protocol">
<meta name="generator" content="xml2rfc v1.36 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">E. Hammer-Lahav, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Yahoo!</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc5849'>5849</a> (if&nbsp;approved)</td><td class="header">D. Recordon</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Facebook</td></tr>
<tr><td class="header">Expires: May 12, 2012</td><td class="header">D. Hardt</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Microsoft</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">November 9, 2011</td></tr>
</table></td></tr></table>
<h1><br />The OAuth 2.0 Authorization Protocol<br />draft-ietf-oauth-v2-22</h1>

<h3>Abstract</h3>

<p>
        OAuth 2.0 は, サードパーティーアプリケーションがHTTPで提供されるサービスとリソースオーナー間に同意の調整を行うか, もしくはサードパーティアプリケーション自身のためにアクセスすることを自ら許可することによって, サービスへの限定されたアクセス権を得ることを可能にする認可プロトコルである. 本仕様書はRFC 5849に記載されているOAuth 1.0 プロトコルを廃止し, その代替となるものである.
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on May 12, 2012.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
はじめに<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
ロール<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
プロトコルフロー<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
認可許諾タイプ<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.3.1.</a>&nbsp;
認可コード<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">1.3.2.</a>&nbsp;
インプリシット<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">1.3.3.</a>&nbsp;
リソースオーナーパスワードクレデンシャル<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">1.3.4.</a>&nbsp;
クライアントクレデンシャル<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">1.4.</a>&nbsp;
アクセストークン<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">1.5.</a>&nbsp;
リフレッシュトークン<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">1.6.</a>&nbsp;
Notational Conventions<br />
<a href="#anchor12">2.</a>&nbsp;
クライアント登録<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client-types">2.1.</a>&nbsp;
クライアントタイプ<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client-identifier">2.2.</a>&nbsp;
クライアント識別子<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#client-authentication">2.3.</a>&nbsp;
クライアント認証<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">2.3.1.</a>&nbsp;
クライアントパスワード<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">2.3.2.</a>&nbsp;
その他の認証方式<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">2.4.</a>&nbsp;
Unregistered Clients<br />
<a href="#anchor16">3.</a>&nbsp;
プロトコルエンドポイント<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">3.1.</a>&nbsp;
認可エンドポイント<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">3.1.1.</a>&nbsp;
レスポンスタイプ<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#redirect-uri">3.1.2.</a>&nbsp;
リダイレクションエンドポイント<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">3.2.</a>&nbsp;
Token Endpoint<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#token-endpoint-auth">3.2.1.</a>&nbsp;
Client Authentication<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">3.3.</a>&nbsp;
Access Token Scope<br />
<a href="#anchor25">4.</a>&nbsp;
Obtaining Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grant-code">4.1.</a>&nbsp;
Authorization Code<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#code-authz-req">4.1.1.</a>&nbsp;
Authorization Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">4.1.2.</a>&nbsp;
Authorization Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">4.1.3.</a>&nbsp;
Access Token Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">4.1.4.</a>&nbsp;
Access Token Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grant-implicit">4.2.</a>&nbsp;
Implicit Grant<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implicit-authz-req">4.2.1.</a>&nbsp;
Authorization Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">4.2.2.</a>&nbsp;
Access Token Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grant-password">4.3.</a>&nbsp;
Resource Owner Password Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">4.3.1.</a>&nbsp;
Authorization Request and Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">4.3.2.</a>&nbsp;
Access Token Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">4.3.3.</a>&nbsp;
Access Token Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#grant-client">4.4.</a>&nbsp;
Client Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor33">4.4.1.</a>&nbsp;
Authorization Request and Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor34">4.4.2.</a>&nbsp;
Access Token Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor35">4.4.3.</a>&nbsp;
Access Token Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">4.5.</a>&nbsp;
Extensions<br />
<a href="#token-issue">5.</a>&nbsp;
アクセストークンの発行<!-- Issuing an Access Token --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#token-response">5.1.</a>&nbsp;
成功レスポンス<!-- Successful Response --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#token-errors">5.2.</a>&nbsp;
エラーレスポンス<!-- Error Response --><br />
<a href="#token-refresh">6.</a>&nbsp;
アクセストークンの更新<!--Refreshing an Access Token--><br />
<a href="#access-resource">7.</a>&nbsp;
保護対象リソースへのアクセス<!-- Accessing Protected Resources --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#token-types">7.1.</a>&nbsp;
アクセストークンタイプ<!-- Access Token Types --><br />
<a href="#extensions">8.</a>&nbsp;
仕様の拡張性<!-- Extensibility --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#new-types">8.1.</a>&nbsp;
アクセストークンタイプの定義<!-- Defining Access Token Types --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor37">8.2.</a>&nbsp;
新たなエンドポイントパラメーターの定義<!-- Defining New Endpoint Parameters --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor38">8.3.</a>&nbsp;
新たな認可グラントタイプの定義<!-- Defining New Authorization Grant Types --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#response-type-ext">8.4.</a>&nbsp;
新たな認可エンドポイントレスポンスタイプの定義<!-- Defining New Authorization Endpoint Response Types --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#new-errors">8.5.</a>&nbsp;
追加のエラーコードの定義<!-- Defining Additional Error Codes --><br />
<a href="#anchor39">9.</a>&nbsp;
ネイティブアプリケーション<!--Native Applications--><br />
<a href="#anchor40">10.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor41">10.1.</a>&nbsp;
クライアント認証<!--Client Authentication--><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor42">10.2.</a>&nbsp;
クライアント偽装<!-- Client Impersonation --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor43">10.3.</a>&nbsp;
アクセストークン<!-- Access Tokens --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor44">10.4.</a>&nbsp;
リフレッシュトークン<!-- Refresh Tokens --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor45">10.5.</a>&nbsp;
認可コード<!-- Authorization Codes --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor46">10.6.</a>&nbsp;
認可コードリダイレクトURIの操作<!--Authorization Code Redirection URI Manipulation--><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor47">10.7.</a>&nbsp;
Resource Owner Password Credentials<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">10.8.</a>&nbsp;
Request Confidentiality<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">10.9.</a>&nbsp;
エンドポイントの真正性<!-- Endpoints Authenticity --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">10.10.</a>&nbsp;
クレデンシャルゲッシングアタック<!-- Credentials Guessing Attacks --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">10.11.</a>&nbsp;
フィッシングアタック<!-- Phishing Attacks --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CSRF">10.12.</a>&nbsp;
クロスサイトリクエストフォージェリ<!-- Cross-Site Request Forgery --><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor52">10.13.</a>&nbsp;
Clickjacking<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor53">10.14.</a>&nbsp;
Code Injection and Input Validation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#open-redirect">10.15.</a>&nbsp;
Open Redirectors<br />
<a href="#anchor54">11.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-registry">11.1.</a>&nbsp;
The OAuth Access Token Type Registry<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor55">11.1.1.</a>&nbsp;
Registration Template<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#parameters-registry">11.2.</a>&nbsp;
The OAuth Parameters Registry<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor56">11.2.1.</a>&nbsp;
Registration Template<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor57">11.2.2.</a>&nbsp;
Initial Registry Contents<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#response-type-registry">11.3.</a>&nbsp;
The OAuth Authorization Endpoint Response Type Registry<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor58">11.3.1.</a>&nbsp;
Registration Template<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor59">11.3.2.</a>&nbsp;
Initial Registry Contents<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#error-registry">11.4.</a>&nbsp;
The OAuth Extensions Error Registry<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor60">11.4.1.</a>&nbsp;
Registration Template<br />
<a href="#anchor61">12.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor62">Appendix&nbsp;A.</a>&nbsp;
Editor's Notes<br />
<a href="#rfc.references1">13.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">13.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">13.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
はじめに</h3>

<p>
        従来のクライアントサーバー型の認証モデルでは, クライアントはリソースオーナーのクレデンシャルを使ってサーバーに対して認証を行いサーバー上の保護されたリソースにアクセスする. つまり, サードパーティーアプリケーションに保護されたリソースへのアクセス権を与えるには, リソースオーナーは自身のクレデンシャルをサードパーティーと共有する必要がある. これはいくつかの問題と制限をもたらす.
      
</p>
<p>
        </p>
<ul class="text">
<li>
            サードパーティーアプリケーションは, 後の利用のためにリソースオーナーのクレデンシャルを保存しておかなければならない. 通常はパスワードが平文で保存されることになる.
          
</li>
<li>
            パスワードを利用することでセキュリティが低下したとしても, サーバーはパスワードベースの認証方式をサポートしなければならない.
          
</li>
<li>
            サードパーティーアプリケーションはリソースオーナーの保護されたリソースに対して過度に広範囲のアクセス権を得ることになり, リソースオーナーは, アクセスをリソースのサブセットに限定したり, アクセス可能な期間を制限したりできない状態のままである.
          
</li>
<li>
            リソースオーナーは各サードパーティーごとにアクセス権を無効化することはできず, アクセス権を無効化する際には全てのサードパーティーが持つアクセス権を無効化しなければならない. つまりそれはパスワード変更を意味する.
          
</li>
<li>
            サードパーティアプリケーションの情報漏えいはエンドユーザーのパスワードおよびパスワードによって保護されている全ての情報の漏洩につながる.
          
</li>
</ul><p>
      
</p>
<p>
        OAuthは, クライアントとリソースオーナーの役割を分けることで, これらの問題の解決に取り組む. OAuthでは, クライアントは, リソースオーナーのコントロール下にありリソースサーバーによってホストされているリソースへのアクセス権を要求する. そしてリソースオーナーのクレデンシャルそのものとは別のクレデンシャルを取得する.
      
</p>
<p>
        クライアントは, 保護されたリソースにアクセスする為にリソースオーナーのクレデンシャルを使う代わりに, アクセストークンを取得する. (アクセストークンとは, ある特定のスコープ, 期間およびその他の属性と紐付けられた文字列である) アクセストークンはリソースオーナーの同意をもって認可サーバーからサードパーティークライアントへ発行される. クライアントはアクセストークンを用いてリソースサーバーがホストしている保護されたリソースにアクセスする.
      
</p>
<p>
        例えば, あるユーザー (リソースオーナー) が, 印刷サービス (クライアント) に対して, 写真共有サービス上 (リソースサーバー) に保管されている彼女の保護された写真へのアクセス権を与えることを考える. OAuthでは, その際彼女のユーザー名とパスワードを印刷サービスに与える必要はない. そのかわり, 彼女は写真共有サービスの信任を得た認証サービス (認証サーバー) に対して認証を行い, 認証サービスが印刷サービスに権限委譲用のクレデンシャル (アクセストークン) を発行する.
      
</p>
<p>
        本仕様書はHTTP<a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>での利用を想定して設計されている. HTTP以外の通信プロトコルでのOAuth利用については未定義である.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
ロール</h3>

<p>
          OAuthは以下４つのロールを定義する
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>リソースオーナー</dt>
<dd>

              
              保護されたリソースへのアクセスを許可するエンティティー. （例：エンドユーザー）
              
            
</dd>
<dt>リソースサーバー</dt>
<dd>

              
              保護されたリソースをホストし, アクセストークンを使っての保護されたリソースへのリクエストを受理してレスポンスを返すことのできるサーバー.
              
            
</dd>
<dt>クライアント</dt>
<dd>

              
              リソースオーナーの認可を得て, 代わりに保護されたリソースに対するリクエストを行うアプリケーション.
              
            
</dd>
<dt>認可サーバー</dt>
<dd>

              
              リソースオーナーの認証とリソースオーナーからの認可取得が成功した後, アクセストークンをクライアントに発行するサーバー.  
              
            
</dd>
</dl></blockquote><p>
        
</p>
<p>
          認可サーバーとリソースサーバー間のやりとりについては本仕様書の範囲外である. 認可サーバーはリソースサーバーと同一のサーバーでも異なるサーバーでもよい. 単一の認可サーバーが複数のリソースサーバーにアクセス可能なアクセストークンを発行してもよい.
        
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
プロトコルフロー</h3>
<br /><hr class="insert" />
<a name="Figure-1"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +--------+                               +---------------+
  |        |--(A)- Authorization Request -&gt;|   Resource    |
  |        |                               |     Owner     |
  |        |&lt;-(B)-- Authorization Grant ---|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
  |        |--(C)-- Authorization Grant --&gt;| Authorization |
  | Client |                               |     Server    |
  |        |&lt;-(D)----- Access Token -------|               |
  |        |                               +---------------+
  |        |
  |        |                               +---------------+
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  |        |--(E)---- アクセストークン ---&gt;|   リソース    |
  |        |                               |   サーバー    |
  |        |&lt;-(F)--- 保護されたリソース ---|               |
=======
  |        |--(E)----- Access Token ------&gt;|    Resource   |
  |        |                               |     Server    |
  |        |&lt;-(F)--- Protected Resource ---|               |
&gt;&gt;&gt;&gt;&gt;&gt;&gt; a3da8e6ff91f8e25f1e12dd31e38c13c91d755e9
  +--------+                               +---------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: プロトコルフローの概要&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
                <a class='info' href='#Figure-1'>Figure&nbsp;1<span> (</span><span class='info'>プロトコルフローの概要</span><span>)</span></a>で示されたフロー概要は, ４つのロール間での相互作用と以下のステップについて記載している.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              クライアントはリソースオーナーからの認可を要求する. その際の認可リクエストはリソースオーナーへ直接送ることが出来るか（図のように）, または間接的に認可サーバを経由して送信できることがのぞましい.
            
</dd>
<dt>(B)</dt>
<dd>
              クライアントは, リソースオーナーの認可許諾を表すクレデンシャルを受け取り, その際は仕様上定義された４つのタイプの１つの許諾タイプか, または拡張された認可形式で発行される. その認可タイプはクライアントの利用する認可リクエストの方式と認可サーバーがサポートする認可タイプ次第である.
            
</dd>
<dt>(C)</dt>
<dd>
              クライアントは認可サーバーに対して自身を認証し, アクセス許可を提示することで, アクセストークンを要求する.
            
</dd>
<dt>(D)</dt>
<dd>
              認可サーバーはクライアント認証とアクセス許可の正当性を確認し, それが正しい場合にアクセストークンを発行する.
            
</dd>
<dt>(E)</dt>
<dd>
              クライアントはリソースサーバの保護されたリソースへリクエストを要求し, 発行されたアクセストークンにより認証を行う.
            
</dd>
<dt>(F)</dt>
<dd>
              リソースサーバはアクセストークンの正当性を確認し, それが正しい場合のみリソースを提供する.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
認可許諾タイプ</h3>

<p>
          リソースオーナーの認可許諾を示すクレデンシャルは, クライアントが利用する取得済みのアクセストークンによって示される.
          この仕様では４つの許諾方式を定義している：認可コード, インプリクト, リソースオーナーパスワードクレデンシャル, クライアントクレデンシャルに加え, 拡張仕様によってタイプを追加することもできる
        
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.1"></a><h3>1.3.1.&nbsp;
認可コード</h3>

<p>
            認可コードは, クライアントとリソースオーナーの仲介者である認可サーバで利用するために取得する. リソースオーナーへ認可リクエストを直接行う代わりに, クライアントをリソースオーナーから認可サーバーへリダイレクトし（<a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>に定義されたユーザーエージェントを経由して）, クライアントをリソースオーナーへリダイレクトする際に一緒に認可コードを返します.
          
</p>
<p>
            クライアントをリソースオーナーにリダイレクトする前に一緒に認可コードを付与し, リソースオーナーとその認可を得たことを認可サーバが認証する. これによりリソースオーナーは認可サーバによってのみ認証され, リソースオーナーのクレデンシャルはクライアントへ共有されない.
          
</p>
<p>
            認可コードは, クライアントを認証する効果や,  リソースオーナーのユーザーエージェントを経由せずリソースオーナーを含む第三者に露出することなしにアクセストークンをクライアントに直接伝搬できるなど, いくつかの点で重要なセキュリティ的なメリットを提供する.
          
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.2"></a><h3>1.3.2.&nbsp;
インプリシット</h3>

<p>
            インプリシット許可はJavaScriptの様なスクリプト言語を使用して, ブラウザで実行されるクライアントに最適化され, 認可コードを単純化したものです. インプリシットフローにおいて, 認可コードを発行する代わりにクライアントは（リソースオーナー認可の結果）直接アクセストークンを発行できる. (認可コードのような)仲介のクレデンシャルが発行されない（そして後にアクセストークンを得られる）許可タイプがインプリシットです.
          
</p>
<p>
            インプリシット許可を発行する時, 認可サーバはクライアントが本物であることを確認しません. ある場合にはクライアントにアクセストークンを渡すのに使用されたリダイレクトURIを通すことでクライアント識別子が検証されることができます. アクセストークンはリソースオーナー, もしくはリソースオーナーのユーザエージェントにアクセスすることで他のアプリケーションに晒されるかもしれない.
          
</p>
<p>
            アクセストークンを得るのに必要な往復の回数を減らせるため, インプリシット許可は（ブラウザにおけるアプリケーションとして実行されたクライアントなど）いくつかのクライアントで反応性と効率性を高めます. しかしながら, この利便性はimplicit許可を使った安全保障の影響でauthorization code許可を利用できる場合は特に一方的に不利になります.
          
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.3"></a><h3>1.3.3.&nbsp;
リソースオーナーパスワードクレデンシャル</h3>

<p>
            リソースオーナーパスワードクレデンシャル（例えばユーザ名とパスワード）がアクセストークンを得るための認可に直接使用されるものである. このクレデンシャルは, リソースオーナーとクライアント（例えばデバイスOSや非常に特権のあるアプリケーション）の間で高い信頼があり, （認可コードのような）他の認可タイプが利用できない場合のみ使用されるべきである.
          
</p>
<p>
            仮にこの許可タイプがリソースオーナークレデンシャルに直接アクセスすることが必要であるとしても, リソースオーナークレデンシャルは１回のリクエストにのみ使用され, アクセストークンに交換される. この認可タイプでは, 寿命の長いアクセストークンやリフレッシュトークンによってクレデンシャルを交換することにより, クライアントがリソースオーナークレデンシャルを将来的に使用する目的で格納しておく必要がなくなる.
          
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.4"></a><h3>1.3.4.&nbsp;
クライアントクレデンシャル</h3>

<p>
            認可範囲がクライアントの管理下の保護されたリソース, もしくは以前認可サーバでアレンジされた保護されたリソースに制限された場合, 認可許可としてクライアントクレデンシャル（もしくは他のクライアント認証形式）が使用できる. クライアントがクライアント自身のために行動している（またはクライアントがリソースオーナー）か, クライアントが以前に認可サーバでアレンジされた認可をベースにした保護されたリソースアクセスを求めている場合, クライアントクレデンシャルは通常の認可許可として使用される.
          
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
アクセストークン</h3>

<p>
          アクセストークンは保護されたリソースにアクセスするために使用されるクレデンシャルである. アクセストークンはクライアントに対して発行される認可を表す文字列である. この文字列は通常クライアントにとって意味が分かりにくい値になっている. トークンはアクセス範囲とアクセス期間を表し, それらはリソースのオーナーによって許可され, リソースサーバーと認可サーバーによって発行される.
        
</p>
<p>
          トークンは認可情報を取り出すための識別子を表したり, 検証可能な方法でそれ自身に認可情報を含んでもよい(データと署名を含むトークン文字列など). 本仕様で定めていない追加の認証クレデンシャルは, クライアントがトークンを使用するために要求されてもよい.
        
</p>
<p>
          アクセストークンによって, 様々な認証要素(例えばユーザ名やパスワード)をリソースサーバーが解釈できる単体のトークンに置き換えるような抽象化レイヤーが提供される. この抽象化はアクセストークンを取得するための認可の付与よりも限定的なトークンの発行を可能とするだけでなく, 広範囲の認証方式をリソースサーバーが解釈する必要性がなくなる.
        
</p>
<p>
          アクセストークンはリソースサーバーのセキュリティ要件に基づいて異なるフォーマット, 構成, および利用方法を持つことができる(暗号の特性). アクセストークンの属性と保護されたリソースにアクセスするための方法は本仕様に定めるところではなく, 付録の仕様書によって定義されている.
        
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.5"></a><h3>1.5.&nbsp;
リフレッシュトークン</h3>

<p>
          リフレッシュトークンはアクセストークンを取得するために使用されるクレデンシャルである. リフレッシュトークンは認可サーバーによってクライアントに対して発行され, 現在のアクセストークンが仕様に一致しないあるいは期限切れの際に新しいアクセストークンを取得するため, または同一あるいは狭い範囲で追加のアクセストークンを取得するために利用される(アクセストークンはリソースオーナーによって認可されるよりも有効期限は短く, 権限が少なくてもよい). リフレッシュトークンの発行はオプションである. 認可サーバーがリフレッシュトークンを発行する場合, アクセストークン発行の際にリフレッシュトークンも含まれる.
        
</p>
<p>
          リフレッシュトークンはリソースオーナーによってクライアントに付与される認可を表す文字列である. この文字列は通常クライアントからみるとランダムな文字列になっている. そのトークンは認可情報を取り出すための識別子を意味してもよい. アクセストークンとは異なり, リフレッシュトークンは認可サーバーでのみ使用されるものであり, リソースサーバーに送信されることはない.
        
</p><br /><hr class="insert" />
<a name="Figure-2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant ---------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(B)----------- Access Token -------------|               |
  |        |               &amp; Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token -----------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(H)----------- Access Token -------------|               |
  +--------+           &amp; Optional Refresh Token        +---------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: 期限切れのアクセストークンのリフレッシュ&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          <a class='info' href='#Figure-2'>Figure&nbsp;2<span> (</span><span class='info'>期限切れのアクセストークンのリフレッシュ</span><span>)</span></a> で示されたフローは以下のステップを含む.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              クライアントは認可サーバーで認証して認可が与えられたことを提示することによって, アクセストークンの要求をする.
            
</dd>
<dt>(B)</dt>
<dd>
              認可サーバーはクライアントを認証して認可が与えられたことを確認し, 有効である場合はアクセストークンとリフレッシュトークンを発行する.
            
</dd>
<dt>(C)</dt>
<dd>
              クライアントはアクセストークンを示すことによってリソースサーバーへの保護されたリソースの要求をする.
            
</dd>
<dt>(D)</dt>
<dd>
              リソースサーバーはアクセストークンの正当性を確認し, 有効な場合はリクエストを処理する.
            
</dd>
<dt>(E)</dt>
<dd>
              ステップ (C) と (D) はアクセストークン有効期限が切れるまで繰り返される. クライアントがアクセストークンの期限切れを検知した場合, ステップ (G) にスキップし, そうでなければ別の保護されたリソースの要求をする.
            
</dd>
<dt>(F)</dt>
<dd>
              アクセストークンが有効でないとき, リソースサーバーは無効なトークンエラーを返す.
            
</dd>
<dt>(G)</dt>
<dd>
              クライアントは, 認可サーバーで認証してリフレッシュトークンを提示することによって, 新しいアクセストークンを要求する. クライアント認証の必要条件はクライアントタイプと認可サーバーのポリシーに基づいている.
            
</dd>
<dt>(H)</dt>
<dd>
              認可サーバーはクライアントを認証しリフレッシュトークンの正当性を確認し, 有効な場合は新しいアクセストークン(と必要に応じてリフレッシュトークン)を発行する.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.6"></a><h3>1.6.&nbsp;
Notational Conventions</h3>

<p>
          本仕様書で用いられる各キーワード「MUST (しなければならない)」, 「MUST NOT (してはならない)」, 「REQUIRED (必須である)」, 「SHALL (するものとする)」, 「SHALL NOT (しないものとする)」, 「SHOULD (すべきである)」, 「SHOULD NOT (すべきではない)」, 「RECOMMENDED (推奨される)」, 「MAY (してもよい)」, 「OPTIONAL (任意である)」は <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> で述べられている通りに解釈されるべきものである.
        
</p>
<p>
          本仕様書は <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a> における Augmented Backus-Naur Form (ABNF) 表記法を使用している.
          <a class='info' href='#RFC5234'>[RFC5234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; January&nbsp;2008.</span><span>)</span></a>.
        
</p>
<p>
          特定のセキュリティ関連の用語は <a class='info' href='#RFC4949'>[RFC4949]<span> (</span><span class='info'>Shirey, R., &ldquo;Internet Security Glossary, Version 2,&rdquo; August&nbsp;2007.</span><span>)</span></a> で定義された意味で理解されるべきである. これらの用語は, 「攻撃 (attack)」, 「認証 (authentication)」, 「認可 (authorization)」, 「証明書 (certificate)」, 「機密性 (confidentiality)」, 「クレデンシャル (credential)」, 「暗号化 (encryption)」, 「アイデンティティ (identity)」, 「記号 (sign)」, 「署名 (signature)」, 「信頼 (trust)」, 「正当性の確認 (validate)」, 「検証 (verify)」に限定されない.
        
</p>
<p>
          特に記載が無い限り, 全てのプロトコルパラメーター名と値は, 大文字・小文字を区別する.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
クライアント登録</h3>

<p>
        データの送受信を開始する前にクライアントは認可サーバに登録する. クライアントが認可サーバに登録する方法はこの仕様での範囲外であるが, 通常エンドユーザとの対話を伴うHTML登録フォームを持つ.
      
</p>
<p>
        クライアントの登録はクライアントと認可サーバ間の直接な相互作用を必須としない. 認可サーバでサポートされている場合, 登録は, 必要なクライアントのプロパティーを取得し, 信頼を確立する他の方法（例えばリダイレクトURIやクライアントタイプ）に頼ることができる. 例えば, 登録は自身で発行, もしくはサードパーティに発行されたアサーションを使用する, または信頼できるチャンネルを使用することでクライアントの発見を行う認可サーバによって行うことができる.
      
</p>
<p>
        クライアントを登録する場合, クライアント開発者は：
      
</p>
<p>
        </p>
<ul class="text">
<li>
            <a class='info' href='#client-types'>Section&nbsp;2.1<span> (</span><span class='info'>クライアントタイプ</span><span>)</span></a>で説明されているようなクライアントタイプを指定します.
          
</li>
<li>
            <a class='info' href='#redirect-uri'>Section&nbsp;3.1.2<span> (</span><span class='info'>リダイレクションエンドポイント</span><span>)</span></a>で説明されているようなリダイレクトURIを提供します. そして, 
          
</li>
<li>
            認可サーバによって他の必須情報を含みます. （例えばアプリケーション名, ウェブサイト, 説明, ロゴイメージ, 利用規則）
          
</li>
</ul><p>
      
</p>
<a name="client-types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
クライアントタイプ</h3>

<p>
          認可サーバと安全に認証する能力に基づいて（つまりクライアントクレデンシャルの機密性を維持できる能力）, OAuthは二つのクライアントタイプを定義している.
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>コンフィデンシャル</dt>
<dd>
              
              クレデンシャルの機密性を維持することができるクライアント（例えば, クライアントクレデンシャルへのアクセスが制限されたセキュアサーバ上に実装されたクライアント）, または他の手段を使用したセキュアなクライアント認証ができるクライアント.
            
            
</dd>
<dt>パブリック</dt>
<dd>
              
	      クレデンシャルの機密性を維持することができないクライアント（例えばインストールされたネイティブアプリケーションやブラウザベースのウェブアプリケーションのようにリソースオーナーのデバイス上で実行するクライアント）, および他の手段を通してセキュアなクライアント認証ができないクライアント.
	      
            
</dd>
</dl></blockquote><p>
        
</p>
<p>
          クライアントタイプの指定はセキュア認証の認可サーバの定義とクライアントクレデンシャルの許容公開レベルに基づいている.
        
</p>
<p>
          この仕様は次のクライアントプロファイルに基づいて設計されている, 
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>ウェブアプリケーション</dt>
<dd>
              
              ウェブアプリケーションはウェブサーバ上で実行されているコンフィデンシャルクライアントである. リソースオーナーがリソースオーナーのデバイス上でユーザエージェントにレンダリングされたHTMLユーザインターフェイスを通してクライアントにアクセスする. クライアントクレデンシャルだけでなく, クライアントに発行されたアクセストークンもWebサーバ上に保存され, リソースオーナーによって公開されたりやアクセス可能な状態にならない.
            
</dd>
<dt>ユーザエージェントベースアプリケーション</dt>
<dd>
              
              ユーザエージェントベースアプリケーションはクライアントコードがWebサーバからダウンロードされ, リソースオーナーのデバイス上でユーザエージェント（例えばWebブラウザ）内で実行されるパブリッククライアントです. プロトコルのデータとクレデンシャルはリソースオーナーに簡単にアクセス（かつ多くの場合は見ること）できる. このようなアプリケーションはユーザエージェント内にあるので, 認可を要求する時ユーザエージェントの能力をシームレスに使用することができる.
            
</dd>
<dt>ネイティブアプリケーション</dt>
<dd>
              
              ネイティブアプリケーションはリソースオーナーのデバイス上にインストールし, 実行できるpublicクライアントです. プロトコルのデータとクレデンシャルはリソースオーナーに公開される. アプリケーションに含まれるいかなるクライアント認証用のクレデンシャルを抽出できることを想定している. 一方, アクセストークンやリフレッシュトークンといった動的に発行されたクレデンシャルは許容できるレベルの保護が得られる. 最低でも, これらのクレデンシャルはアプリケーションと対話できる悪意のあるサーバから保護されている. いくつかのプラットフォーム上でこれらのクレデンシャルは同じデバイス上に存在する他のアプリケーションから保護されることがある.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="client-identifier"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
クライアント識別子</h3>

<p>
          認可サーバーは登録済みのクライアントにクライアント識別子（クライアントが提供した登録情報を表すユニーク文字列）を発行する. クライアント識別子はシークレットと異なり, リソースオーナーに露出されるため, クライアント認証に単独で利用してはならない（MUST NOT）.
        
</p>
<a name="client-authentication"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
クライアント認証</h3>

<p>
          クライアントタイプがコンフィデンシャルである場合, クライアントと認可サーバーは, 認可サーバーのセキュリティ要求を満たすクライアント認証方式を確立する. 認可サーバーは自身のセキュリティ要求を満たすあらゆる方式のクライアント認証に対応してもよい（MAY）
        
</p>
<p>
          コンフィデンシャルクライアントには, 通常は認可サーバーでの認証に使われるクライアントクレデンシャルのセットが発行（もしくは確立）される. 例）パスワード, 公開鍵／秘密鍵のペア
        
</p>
<p>
          認可サーバーはクライアントタイプを仮定したり, クライアントとその開発者との信頼確立せずに提供されたタイプ情報に対応すべきではない（SHOULD NOT）. 認可サーバーはパブリッククライアントとクライアント認証によって信頼確立してもよい（MAY）. しかし, 認可サーバーはクライアントを識別する目的で, パブリッククライアントを信頼してはならない（MUST NOT）.
        
</p>
<p>
          クライアントは各リクエストにおいて二つ以上の認証方式を利用してはならない（MUST NOT）.
        
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
クライアントパスワード</h3>

<p>
                  クライアントパスワードを保持しているクライアントは, 認可サーバー上での認証に<a class='info' href='#RFC2617'>[RFC2617]<span> (</span><span class='info'>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, &ldquo;HTTP Authentication: Basic and Digest Access Authentication,&rdquo; June&nbsp;1999.</span><span>)</span></a>で定義されている HTTP Basic 認証スキームを使用してもよい（MAY）. クライアント識別子はユーザー名, クライアントパスワードはパスワードとして利用される.
          
</p>
<p>
              サンプル:
	      
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW

</pre></div>
<p>
            認可サーバーは以下のパラメータを用いて, リクエストボディにクライアントクレデンシャルを含めてもよい（MAY）.
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>client_id</dt>
<dd>
                
                必須（REQUIRED）. <a class='info' href='#client-identifier'>Section&nbsp;2.2<span> (</span><span class='info'>クライアント識別子</span><span>)</span></a>に示されるクライアント登録手順にて発行されたクライアント識別子.
		
              
</dd>
<dt>client_secret</dt>
<dd>
                
                必須（REQUIRED）. クライアントのシークレット. 空の場合は省略してもよい（MAY）.
		
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            ２つのパラメータを使ってクライアントクレデンシャルをリクエストボディに含めることは推奨されていない（NOT RECOMMENDED）. また, それはHTTP Basic 認証スキーム（もしくは他のパスワードベースのHTTP認証スキーム）が直接利用できないクライアントに限定すべきある.
          
</p>
<p>
              例：ボディパラメータを使ってアクセストークンの更新 (<a class='info' href='#token-refresh'>Section&nbsp;6<span> (</span><span class='info'>アクセストークンの更新<!--Refreshing an Access Token--></span><span>)</span></a>）のリクエストを送信する場合（改行は見やすくするために付与している）
	          
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
  &amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw

</pre></div>
<p>
            トークンエンドポイントにリクエスト送信する際に, 平文のクレデンシャルを送信することになるので, 認可サーバーはTLSを使用することを要求しなければならない（MUST）.
          
</p>
<p>
            クライアント認証方式にパスワードが含まれるので, 認可サーバーはブルートフォースアタック対策のために全てのエンドポイントを保護しなくてはならない（MUST）.
          
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
その他の認証方式</h3>

<p>
            認証サーバは, セキュリティ要件に適合する適切なHTTP認証スキームをサポートすべきである（MAY）. 他の認証方式を利用する際には, 認可サーバはClient Identifierと認証方式の双方をマッピングしておかねばならない（MUST）. 
          
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Unregistered Clients</h3>

<p>
          この仕様は, 未登録のクライアントでの利用を排除するものではない. しかしながら, 追加的にセキュリティ面の保障を必要とする場合, 相互運用性への影響を評価する場合, このようなクライアントの利用方法はこの仕様のおけるスコープを越える. 
        
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
プロトコルエンドポイント</h3>

<p>
        認可プロセスは2つのエンドポイントを利用する (HTTP リソース):
      
</p>
<p>
        </p>
<ul class="text">
<li>
            認可エンドポイント - ユーザーエージェントによってリソースオーナーから認可を得るために利用される.
          
</li>
<li>
            トークンエンドポイント - 認可の付与とアクセストークンと交換するために利用される. 一般的にクライアント認証を用いる.
          
</li>
</ul><p>
      
</p>
<p>
        全ての認可タイプが両方のエンドポイントを使用するわけではない. 拡張された許可タイプは必要に応じて追加のエンドポイントを定義してもよい (MAY).
      
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
認可エンドポイント</h3>

<p>
          認可エンドポイントはリソースオーナーと通信するために使用され認可が与えられる. 認可サーバーはリソースオーナーのアイデンティティを確認しなければならない (MUST). 認可サーバーがリソースオーナーの認証方法 (ユーザー名やパスワードによるログイン, セッション・クッキー) は本仕様の定めるところではない.
        
</p>
<p>
          クライアントの認可エンドポイントURLの取得は本仕様の定めるところではないが, そのURLは一般的にサービスドキュメントで提供される.
        
</p>
<p>
          エンドポイントのURIは (<a class='info' href='#W3C.REC-html401-19991224'>[W3C.REC&#8209;html401&#8209;19991224]<span> (</span><span class='info'>Raggett, D., Jacobs, I., and A. Hors, &ldquo;HTML 4.01 Specification,&rdquo; December&nbsp;1999.</span><span>)</span></a>) でフォーマットされたクエリー部に <tt>application/x-www-form-urlencoded</tt> を含んでもよい (MAY) (<a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> section 3.4). そのクエリーパラメータは他のクエリーパラメーターを追加する場合, そのままにしなければならない (MUST). エンドポイントURIはフラグメント部を含んではいけない (MUST NOT).
        
</p>
<p>
          認可エンドポイントへのリクエストはユーザー認証と(HTTPレスポンスによる)平文クレデンシャルの転送を伴うため, 認可エンドポイントにリクエストを送信する際, 認可サーバーはトランスポート層でのセキュリティ機構を用いらなければならない (MUST). 認可サーバーはTLS 1.0 (<a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>) をサポートしなければならず (MUST), TLS 1.2 (<a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>) とその将来的な切り替えをサポートすべきであり (SHOULD), セキュリティ要件に合わせた追加のトランスポート層メカニズムをサポートしてもよい (MAY).
        
</p>
<p>
          認可サーバーは認可エンドポイントでHTTP <tt>GET</tt> メソッドをサポートしなければならず (MUST), 同様に <tt>POST</tt> メソッドをサポートしてもよい (MAY).
        
</p>
<p>
          パラメーターの値がない場合は, パラメーター自体が省略されているものとして扱わなければならない (MUST). 認可サーバーは認められていないリクエストパラメーターは無視すべきである (SHOULD). リクエストおよびレスポンスパラメーターは2回以上含まれるべきではない (MUST NOT).
        
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
レスポンスタイプ</h3>

<p>
            認可エンドポイントは認可コード許可タイプと implicit 許可タイプのフローで使用される. クライアントは以下に示すパラメーターを利用した希望するタイプの認可サーバーに情報を送る.
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>response_type</dt>
<dd>
                
                必須 (REQUIRED).
                レスポンスタイプの値は <a class='info' href='#code-authz-req'>Section&nbsp;4.1.1<span> (</span><span class='info'>Authorization Request</span><span>)</span></a> で述べる認可コードを要求するための <tt>code</tt> あるいは, <a class='info' href='#implicit-authz-req'>Section&nbsp;4.2.1<span> (</span><span class='info'>Authorization Request</span><span>)</span></a> で述べるアクセストークン(インプリシット許可)を要求する <tt>token</tt> あるいは, <a class='info' href='#response-type-ext'>Section&nbsp;8.4<span> (</span><span class='info'>新たな認可エンドポイントレスポンスタイプの定義<!-- Defining New Authorization Endpoint Response Types --></span><span>)</span></a> で述べる登録されている拡張された値のいずれかでなければならない (MUST). レスポンスタイプに1つ以上の空白文字(%x20)が含まれている場合, 値の順序は問題としない値の空白区切り一覧(<tt>a b</tt> と <tt>b a</tt> は同じである)として無視する.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            認可リクエストで <tt>response_type</tt> を見つけられない場合, 認可サーバーは <a class='info' href='#code-authz-error'>Section&nbsp;4.1.2.1<span> (</span><span class='info'>Error Response</span><span>)</span></a> で述べるエラーレスポンスを返すべきである (SHOULD).
          
</p>
<a name="redirect-uri"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
リダイレクションエンドポイント</h3>

<p>
            リソースオーナーとのやりとりが完了した後, 認証サーバはリソースオーナーのユーザエージェントをクライアントへ誘導する. 認証サーバはユーザエージェントをクライアント登録プロセス中, もしくは認可リクエスト時に認可サーバに事前に確立されたクライアントのリダイレクションエンドポイントへリダイレクする.
          
</p>
<p>
		  リダイレクションURIは<a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>セクション4.3で定義されているように絶対URIでなければいけない(MUST). エンドポイントURIは"application/x-www-form-urlencoded"でフォーマットされたクエリコンポーネントを含んでもよい(MAY). 追加クエリパラメータを追加する場合, これは保持されなければいけない(MUST).エンドポイントURIはフラグメントコンポーネントを含んではいけない(MUST NOT).
          
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.1"></a><h3>3.1.2.1.&nbsp;
エンドポイントリクエストの機密性</h3>

<p>
              もしリダイレクションリクエストが（リソースオーナーのユーザエージェントとクライアントの間で）オープンなネットワークにわたって認可コードやアクセストークンの通信が生じるなら, クライアントはトランスポート層でのセキュリティメカニズムの使用を求めるべきである（SHOULD）.
            
</p>
<p>
              トランスポート層のセキュリティの欠如はクライアントとアクセス認証された保護リソース上で深刻な影響を及ぼす. トランスポート層のセキュリティを使用することは、認可プロセスがクライアントによってエンドユーザ認証の委譲された形式で使用される場合特に重要である（例えばサードパーティサインインサービス）.
            
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.2"></a><h3>3.1.2.2.&nbsp;
登録要件</h3>

<p>
              認可エンドポイントを使用する前に認可サーバはリダイレクションURIを登録することをクライアント全てに要求するべきです（SHOULD）. 以下のクライアントはリダイレクションURIの登録を要求しなければいけない（MUST）.
            
</p>
<p>
              </p>
<ul class="text">
<li>
                  パブリッククライアント.
                
</li>
<li>
                  インプリシット認可タイプを利用しているコンフィデンシャルクライアント.
                
</li>
</ul><p>
            
</p>
<p>
		    認可サーバは完全なリダイレクションURI（クライアントはリクエスト毎のカスタマイズを得るため<tt>state</tt>リクエストパラメータを使用してもよい（MAY））の提供をクライアントに要求するべきです（SHOULD）. 認可サーバはクライアントに複数のリダイレクトURIの登録を許可するべきである（MAY）. 完全なリダイレクションURIの登録を要求することが可能出ないなら, 認可サーバはURIスキーム, 権限, パス（認可要求の時, リダイレクションURIのクエリーコンポーネントのみ動的に変更を許可する）の登録を要求するべきである（SHOULD）.
            
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.3"></a><h3>3.1.2.3.&nbsp;
動的設定</h3>

<p>
              リダイレクションURIが複数登録されていた場合, リダイレクションURIの一部のみ登録されていた場合, もしくはリダイレクションURIが登録されていなかった場合, クライアントは<tt>redirect_uri</tt>リクエストパラメータを使用して認可リクエストでリダイレクションURIを含まなければいけない（MUST）.
            
</p>
<p>
              リダイレクションURIが認可リクエストに含まれていた時, いくつかのリダイレクションURIが登録されていた場合<a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>セクション6で説明されているように登録されているリダイレクションURI（もしくはURIコンポーネント）のうちの少なくとも一つに対して受け取った値と比較し一致しなければいけない.もしクライアントの登録にフルのリダイレクションURIが含まれていた場合, 認可サーバは<a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>セクション6.2.1.で定義されているように単純な文字列比較を使用し二つのURIを比較しなければいけない（MUST）.
            
</p>
<p>
               認可サーバがリダイレクションURIのクエリコンポーネントの動的変更をクライアントに許可するなら, 攻撃者が<a class='info' href='#open-redirect'>Section&nbsp;10.15<span> (</span><span class='info'>Open Redirectors</span><span>)</span></a>で説明されているようにリダイレクションエンドポイントの乱用できないことによってクライアントはクエリコンポーネントの操作を保証しなければいけない.
             
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.4"></a><h3>3.1.2.4.&nbsp;
無効なエンドポイント</h3>

<p>
              認可リクエストがリダイレクションURIの欠落, 無効, もしくは不一致のため検証失敗なら, 認可サーバはエラーをリソースオーナーに知らせるべきである（SHOULD）. そして無効なリダイレクションURIにユーザエージェントを自動でリダイレクトしてはいけない（MUST NOT）.
            
</p>
<p>
              認可サーバは認可エンドポイントをオープンリダイレクタとして使われることから防ぐために登録されていない, もしくは信頼できないURIにユーザエージェントをリダイレクトするべきでない（SHOULD NOT）.
            
</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.5"></a><h3>3.1.2.5.&nbsp;
エンドポイントコンテント</h3>

<p>
              クライアントのエンドポイントへのリダイレクションリクエストは通常ユーザエージェントによって処理されたHTMLドキュメントを返される. HTMLレスポンスがリダイレクションリクエストの結果直接提供するなら, HTMLドキュメントに含まれるスクリプトがにリダイレクションURIとそれに含まれるクレデンシャルへのフルアクセスが実行する.
            
</p>
<p>
              クライアントはURIからクレデンシャルを抽出し削除するのに使用される独自のスクリプトが最初に実行されることを確認せず, リダイレクションエンドポイントのレスポンスに信頼できないサードパーティのスクリプトを含んではいけない（MUST NOT）（例えばサードパーティの分析性, ソーシャルプラグイン, 広告ネットワーク）.
            
</p>
<p>
              クライアントはリダイレクションエンドポイントのレスポンスにサードパーティスクリプトを含めるべきではない（SHOULD NOT）. 代わりにそのURIからクレデンシャルを抽出し, URIのクレデンシャルなしで別のエンドポイントへ再びユーザエージェントをリダイレクトするべきです.
            
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Token Endpoint</h3>

<p>
          The token endpoint is used by the client to obtain an access token by presenting its
          authorization grant or refresh token. The token endpoint is used with every authorization
          grant except for the implicit grant type (since an access token is issued directly).
        
</p>
<p>
          The means through which the client obtains the location of the token endpoint are
          beyond the scope of this specification but is typically provided in the service
          documentation.
        
</p>
<p>
          The endpoint URI MAY include an
          <tt>application/x-www-form-urlencoded</tt> formatted
          (<a class='info' href='#W3C.REC-html401-19991224'>[W3C.REC&#8209;html401&#8209;19991224]<span> (</span><span class='info'>Raggett, D., Jacobs, I., and A. Hors, &ldquo;HTML 4.01 Specification,&rdquo; December&nbsp;1999.</span><span>)</span></a>) query component (<a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>
          section 3.4), which MUST be retained when adding additional query parameters. The
          endpoint URI MUST NOT include a fragment component.
        
</p>
<p>
          Since requests to the token endpoint result in the transmission of clear-text credentials
          (in the HTTP request and response), the authorization server MUST require the use of a
          transport-layer security mechanism when sending requests to the token endpoint. The
          authorization server MUST support TLS 1.0 (<a class='info' href='#RFC2246'>[RFC2246]<span> (</span><span class='info'>Dierks, T. and C. Allen, &ldquo;The TLS Protocol Version 1.0,&rdquo; January&nbsp;1999.</span><span>)</span></a>), SHOULD support TLS
          1.2 (<a class='info' href='#RFC5246'>[RFC5246]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a>) and its future replacements, and MAY support additional
          transport-layer mechanisms meeting its security requirements.
        
</p>
<p>
          The client MUST use the HTTP <tt>POST</tt> method when making access
          token requests.
        
</p>
<p>
          Parameters sent without a value MUST be treated as if they were omitted from the request.
          The authorization server SHOULD ignore unrecognized request parameters. Request and
          response parameters MUST NOT be included more than once.
        
</p>
<a name="token-endpoint-auth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Client Authentication</h3>

<p>
            Confidential clients, clients issued client credentials, or clients assigned other
            authentication requirements MUST authenticate with the authorization server as
            described in <a class='info' href='#client-authentication'>Section&nbsp;2.3<span> (</span><span class='info'>クライアント認証</span><span>)</span></a> when making requests to the token
            endpoint. Client authentication is used for:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Enforcing the binding of refresh tokens and authorization codes to the client they
                are issued. Client authentication is critical when an authorization code is
                transmitted to the redirection endpoint over an insecure channel, or when the
                redirection URI has not been registered in full.
              
</li>
<li>
                Recovering from a compromised client by disabling the client or changing its
                credentials, thus preventing an attacker from abusing stolen refresh tokens. Changing
                a single set of client credentials is significantly faster than revoking an entire
                set of refresh tokens.
              
</li>
<li>
                Implementing authentication management best practices which require periodic
                credential rotation. Rotation of an entire set of refresh tokens can be
                challenging, while rotation of a single set of client credentials is significantly
                easier.
              
</li>
</ul><p>
          
</p>
<p>
            A public client that was not issued a client password MAY use the
            <tt>client_id</tt> request parameter to identify itself when sending
            requests to the token endpoint.
          
</p>
<p>
            The security ramifications of allowing unauthenticated access by public clients to the
            token endpoint, as well as the issuance of refresh tokens to public clients MUST be
            taken into consideration.
          
</p>
<a name="scope"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Access Token Scope</h3>

<p>
          The authorization and token endpoints allow the client to specify the scope of the access
          request using the <tt>scope</tt> request parameter. In turn, the
          authorization server uses the <tt>scope</tt> response parameter to
          inform the client of the scope of the access token issued.
        
</p>
<p>
          The value of the scope parameter is expressed as a list of space-delimited, case
          sensitive strings. The strings are defined by the authorization server. If the value
          contains multiple space-delimited strings, their order does not matter, and each string
          adds an additional access range to the requested scope.
        
</p>
<p>
          The authorization server MAY fully or partially ignore the scope requested by the client
          based on the authorization server policy or the resource owner's instructions. If the
          issued access token scope is different from the one requested by the client, the
          authorization server SHOULD include the <tt>scope</tt> response
          parameter to inform the client of the actual scope granted.
      
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Obtaining Authorization</h3>

<p>
        To request an access token, the client obtains authorization from the resource owner. The
        authorization is expressed in the form of an authorization grant which the client uses to
        request the access token. OAuth defines four grant types: authorization code, implicit,
        resource owner password credentials, and client credentials. It also provides an extension
        mechanism for defining additional grant types.
      
</p>
<a name="grant-code"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Authorization Code</h3>

<p>
          The authorization code grant type is used to obtain both access tokens and refresh
          tokens and is optimized for confidential clients. As a redirection-based flow, the client
          must be capable of interacting with the resource owner's user-agent (typically a web
          browser) and capable of receiving incoming requests (via redirection) from the
          authorization server.
        
</p><br /><hr class="insert" />
<a name="Figure-3"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +----------+
  | resource |
  |   owner  |
  |          |
  +----------+
       ^
       |
      (B)
  +----|-----+          Client Identifier      +---------------+
  |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
  |  User-   |                                 | Authorization |
  |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
  |          |                                 |               |
  |         -+----(C)-- Authorization Code ---&lt;|               |
  +-|----|---+                                 +---------------+
    |    |                                         ^      v
   (A)  (C)                                        |      |
    |    |                                         |      |
    ^    v                                         |      |
  +---------+                                      |      |
  |         |&gt;---(D)-- Authorization Code ---------'      |
  |  Client |          &amp; Redirection URI                  |
  |         |                                             |
  |         |&lt;---(E)----- Access Token -------------------'
  +---------+       (w/ Optional Refresh Token)

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Authorization Code Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          The flow illustrated in <a class='info' href='#Figure-3'>Figure&nbsp;3<span> (</span><span class='info'>Authorization Code Flow</span><span>)</span></a> includes the following steps:
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              The client initiates the flow by directing the resource owner's user-agent to the
              authorization endpoint. The client includes its client identifier, requested
              scope, local state, and a redirection URI to which the authorization server will send
              the user-agent back once access is granted (or denied).
            
</dd>
<dt>(B)</dt>
<dd>
              The authorization server authenticates the resource owner (via the user-agent) and
              establishes whether the resource owner grants or denies the client's access request.
            
</dd>
<dt>(C)</dt>
<dd>
              Assuming the resource owner grants access, the authorization server redirects the
              user-agent back to the client using the redirection URI provided earlier (in the
              request or during client registration). The redirection URI includes an authorization
              code and any local state provided by the client earlier.
            
</dd>
<dt>(D)</dt>
<dd>
              The client requests an access token from the authorization server's token endpoint
              by including the authorization code received in the previous step. When making the
              request, the client authenticates with the authorization server. The client includes
              the redirection URI used to obtain the authorization code for verification.
            
</dd>
<dt>(E)</dt>
<dd>
              The authorization server authenticates the client, validates the authorization code,
              and ensures the redirection URI received matches the URI used to redirect the client
              in step (C). If valid, the authorization server responds back with an access token
              and optional refresh token.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="code-authz-req"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Authorization Request</h3>

<p>
            The client constructs the request URI by adding the following parameters to the
            query component of the authorization endpoint URI using the
            <tt>application/x-www-form-urlencoded</tt> format as defined by
            <a class='info' href='#W3C.REC-html401-19991224'>[W3C.REC&#8209;html401&#8209;19991224]<span> (</span><span class='info'>Raggett, D., Jacobs, I., and A. Hors, &ldquo;HTML 4.01 Specification,&rdquo; December&nbsp;1999.</span><span>)</span></a>:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>response_type</dt>
<dd>
                
                REQUIRED. Value MUST be set to <tt>code</tt>.
              
</dd>
<dt>client_id</dt>
<dd>
                
                REQUIRED. The client identifier as described in
                <a class='info' href='#client-identifier'>Section&nbsp;2.2<span> (</span><span class='info'>クライアント識別子</span><span>)</span></a>.
              
</dd>
<dt>redirect_uri</dt>
<dd>
                
                OPTIONAL, as described in <a class='info' href='#redirect-uri'>Section&nbsp;3.1.2<span> (</span><span class='info'>リダイレクションエンドポイント</span><span>)</span></a>.
              
</dd>
<dt>scope</dt>
<dd>
                
                OPTIONAL. The scope of the access request as described by <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>.
              
</dd>
<dt>state</dt>
<dd>
                
                RECOMMENDED. An opaque value used by the client to maintain state between the request
                and callback. The authorization server includes this value when redirecting the
                user-agent back to the client. The parameter SHOULD be used for preventing
                cross-site request forgery as described in <a class='info' href='#CSRF'>Section&nbsp;10.12<span> (</span><span class='info'>クロスサイトリクエストフォージェリ<!-- Cross-Site Request Forgery --></span><span>)</span></a>.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            The client directs the resource owner to the constructed URI using an HTTP redirection
            response, or by other means available to it via the user-agent.
          
</p>
<p>
              For example, the client directs the user-agent to make the following HTTP request
              using transport-layer security (extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
      &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com

</pre></div>
<p>
            The authorization server validates the request to ensure all required parameters are
            present and valid. If the request is valid, the authorization server authenticates the
            resource owner and obtains an authorization decision (by asking the resource owner or
            by establishing approval via other means).
          
</p>
<p>
            When a decision is established, the authorization server directs the user-agent to the
            provided client redirection URI using an HTTP redirection response, or by other means
            available to it via the user-agent.
          
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Authorization Response</h3>

<p>
            If the resource owner grants the access request, the authorization server issues an
            authorization code and delivers it to the client by adding the following parameters to
            the query component of the redirection URI using the
            <tt>application/x-www-form-urlencoded</tt> format:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>code</dt>
<dd>
                
                REQUIRED. The authorization code generated by the authorization server. The
                authorization code MUST expire shortly after it is issued to mitigate the risk of
                leaks. A maximum authorization code lifetime of 10 minutes is RECOMMENDED. The
                client MUST NOT use the authorization code more than once. If an authorization code
                is used more than once, the authorization server MUST deny the request and SHOULD
                attempt to revoke all tokens previously issued based on that authorization code.
                The authorization code is bound to the client identifier and redirection URI.
              
</dd>
<dt>state</dt>
<dd>
                
                REQUIRED if the <tt>state</tt> parameter was present in the
                client authorization request. The exact value received from the client.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
              For example, the authorization server redirects the user-agent by sending the
              following HTTP response:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
            &amp;state=xyz

</pre></div>
<p>
            The client SHOULD ignore unrecognized response parameters. The authorization code
            string size is left undefined by this specification. The client should avoid making
            assumptions about code value sizes. The authorization server should document the size
            of any value it issues.
          
</p>
<a name="code-authz-error"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2.1"></a><h3>4.1.2.1.&nbsp;
Error Response</h3>

<p>
              If the request fails due to a missing, invalid, or mismatching redirection URI, or if
              the client identifier provided is invalid, the authorization server SHOULD inform the
              resource owner of the error, and MUST NOT automatically redirect the user-agent to
              the invalid redirection URI.
            
</p>
<p>
              If the resource owner denies the access request or if the request fails for reasons
              other than a missing or invalid redirection URI, the authorization server informs the
              client by adding the following parameters to the query component of the redirection
              URI using the <tt>application/x-www-form-urlencoded</tt> format:
            
</p>
<p>
              </p>
<blockquote class="text"><dl>
<dt>error</dt>
<dd>
                  
                  REQUIRED. A single error code from the following:

                  
<blockquote class="text"><dl>
<dt>invalid_request</dt>
<dd>
                      
                      The request is missing a required parameter, includes an unsupported
                      parameter value, or is otherwise malformed.
                    
</dd>
<dt>unauthorized_client</dt>
<dd>
                      
                      The client is not authorized to request an authorization code using this
                      method.
                    
</dd>
<dt>access_denied</dt>
<dd>
                      
                      The resource owner or authorization server denied the request.
                    
</dd>
<dt>unsupported_response_type</dt>
<dd>
                      
                      The authorization server does not support obtaining an authorization code
                      using this method.
                    
</dd>
<dt>invalid_scope</dt>
<dd>
                      
                      The requested scope is invalid, unknown, or malformed.
                    
</dd>
<dt>server_error</dt>
<dd>
                      
                      The authorization server encountered an unexpected condition which prevented
                      it from fulfilling the request.
                    
</dd>
<dt>temporarily_unavailable</dt>
<dd>
                      
                      The authorization server is currently unable to handle the request due to a
                      temporary overloading or maintenance of the server.
                    
</dd>
</dl></blockquote>
                
</dd>
<dt>error_description</dt>
<dd>
                  
                  OPTIONAL. A human-readable UTF-8 encoded text providing additional information,
                  used to assist the client developer in understanding the error that occurred.
                
</dd>
<dt>error_uri</dt>
<dd>
                  
                  OPTIONAL. A URI identifying a human-readable web page with information about the
                  error, used to provide the client developer with additional information about the
                  error.
                
</dd>
<dt>state</dt>
<dd>
                  
                  REQUIRED if a valid <tt>state</tt> parameter was present in the
                  client authorization request. The exact value received from the client.
                
</dd>
</dl></blockquote><p>
            
</p>
<p>
                For example, the authorization server redirects the user-agent by sending the
                following HTTP response:
              
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 302 Found
  Location: https://client.example.com/cb?error=access_denied&amp;state=xyz

</pre></div>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Access Token Request</h3>

<p>
            The client makes a request to the token endpoint by adding the following parameters
            using the <tt>application/x-www-form-urlencoded</tt> format in the
            HTTP request entity-body:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>grant_type</dt>
<dd>
                
                REQUIRED. Value MUST be set to <tt>authorization_code</tt>.
              
</dd>
<dt>code</dt>
<dd>
                
                REQUIRED. The authorization code received from the authorization server.
              
</dd>
<dt>redirect_uri</dt>
<dd>
                
                REQUIRED, if the <tt>redirect_uri</tt> parameter was included in
                the authorization request as described in <a class='info' href='#code-authz-req'>Section&nbsp;4.1.1<span> (</span><span class='info'>Authorization Request</span><span>)</span></a>, and
                their values MUST be identical.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            If the client type is confidential or the client was issued client credentials (or
            assigned other authentication requirements), the client MUST authenticate with the
            authorization server as described in <a class='info' href='#token-endpoint-auth'>Section&nbsp;3.2.1<span> (</span><span class='info'>Client Authentication</span><span>)</span></a>.
          
</p>
<p>
              For example, the client makes the following HTTP request using transport-layer security
              (extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
  &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb

</pre></div>
<p>
            The authorization server MUST:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                require client authentication for confidential clients or for any client that was
                issued client credentials (or with other authentication requirements),
              
</li>
<li>
                authenticate the client if client authentication is included and ensure the
                authorization code was issued to the authenticated client,
              
</li>
<li>
                verify that the authorization code is valid, and
              
</li>
<li>
                ensure that the <tt>redirect_uri</tt> parameter is present if
                the <tt>redirect_uri</tt> parameter was included in the initial
                authorization request as described in <a class='info' href='#code-authz-req'>Section&nbsp;4.1.1<span> (</span><span class='info'>Authorization Request</span><span>)</span></a>, and if
                included ensure their values are identical.
              
</li>
</ul><p>
          
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.4"></a><h3>4.1.4.&nbsp;
Access Token Response</h3>

<p>
            If the access token request is valid and authorized, the authorization server issues an
            access token and optional refresh token as described in <a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a>.
            If the request client authentication failed or is invalid, the authorization server returns
            an error response as described in <a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>.
          
</p>
<p>
              An example successful response:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
  }

</pre></div>
<a name="grant-implicit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Implicit Grant</h3>

<p>
          The implicit grant type is used to obtain access tokens (it does not support the issuance
          of refresh tokens) and is optimized for public clients known to operate a particular
          redirection URI. These clients are typically implemented in a browser using a scripting
          language such as JavaScript.
        
</p>
<p>
          As a redirection-based flow, the client must be capable of interacting with the
          resource owner's user-agent (typically a web browser) and capable of receiving incoming
          requests (via redirection) from the authorization server.
        
</p>
<p>
          Unlike the authorization code grant type in which the client makes separate requests for
          authorization and access token, the client receives the access token as the result of the
          authorization request.
        
</p>
<p>
          The implicit grant type does not include client authentication, and relies on the
          presence of the resource owner and the registration of the redirection URI. Because the
          access token is encoded into the redirection URI, it may be exposed to the resource owner
          and other applications residing on its device.
        
</p><br /><hr class="insert" />
<a name="Figure-4"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +----------+
  | Resource |
  |  Owner   |
  |          |
  +----------+
       ^
       |
      (B)
  +----|-----+          Client Identifier     +---------------+
  |         -+----(A)-- &amp; Redirection URI ---&gt;|               |
  |  User-   |                                | Authorization |
  |  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
  |          |                                |               |
  |          |&lt;---(C)--- Redirection URI ----&lt;|               |
  |          |          with Access Token     +---------------+
  |          |            in Fragment
  |          |                                +---------------+
  |          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
  |          |          without Fragment      |     Client    |
  |          |                                |    Resource   |
  |     (F)  |&lt;---(E)------- Script ---------&lt;|               |
  |          |                                +---------------+
  +-|--------+
    |    |
   (A)  (G) Access Token
    |    |
    ^    v
  +---------+
  |         |
  |  Client |
  |         |
  +---------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Implicit Grant Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          The flow illustrated in <a class='info' href='#Figure-4'>Figure&nbsp;4<span> (</span><span class='info'>Implicit Grant Flow</span><span>)</span></a> includes the following steps:
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              The client initiates the flow by directing the resource owner's user-agent to the
              authorization endpoint. The client includes its client identifier, requested
              scope, local state, and a redirection URI to which the authorization server will send
              the user-agent back once access is granted (or denied).
            
</dd>
<dt>(B)</dt>
<dd>
              The authorization server authenticates the resource owner (via the user-agent) and
              establishes whether the resource owner grants or denies the client's access request.
            
</dd>
<dt>(C)</dt>
<dd>
              Assuming the resource owner grants access, the authorization server redirects the
              user-agent back to the client using the redirection URI provided earlier. The
              redirection URI includes the access token in the URI fragment.
            
</dd>
<dt>(D)</dt>
<dd>
              The user-agent follows the redirection instructions by making a request to the
              web-hosted client resource (which does not include the fragment). The user-agent
              retains the fragment information locally.
            
</dd>
<dt>(E)</dt>
<dd>
              The web-hosted client resource returns a web page (typically an HTML document with an
              embedded script) capable of accessing the full redirection URI including the fragment
              retained by the user-agent, and extracting the access token (and other parameters)
              contained in the fragment.
            
</dd>
<dt>(F)</dt>
<dd>
              The user-agent executes the script provided by the web-hosted client resource
              locally, which extracts the access token and passes it to the client.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="implicit-authz-req"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Authorization Request</h3>

<p>
            The client constructs the request URI by adding the following parameters to the
            query component of the authorization endpoint URI using the
            <tt>application/x-www-form-urlencoded</tt> format:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>response_type</dt>
<dd>
                
                REQUIRED. Value MUST be set to <tt>token</tt>.
              
</dd>
<dt>client_id</dt>
<dd>
                
                REQUIRED. The client identifier as described in
                <a class='info' href='#client-identifier'>Section&nbsp;2.2<span> (</span><span class='info'>クライアント識別子</span><span>)</span></a>.
              
</dd>
<dt>redirect_uri</dt>
<dd>
                
                OPTIONAL, as described in <a class='info' href='#redirect-uri'>Section&nbsp;3.1.2<span> (</span><span class='info'>リダイレクションエンドポイント</span><span>)</span></a>.
              
</dd>
<dt>scope</dt>
<dd>
                
                OPTIONAL. The scope of the access request as described by <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>.
              
</dd>
<dt>state</dt>
<dd>
                
                RECOMMENDED. An opaque value used by the client to maintain state between the request
                and callback. The authorization server includes this value when redirecting the
                user-agent back to the client. The parameter SHOULD be used for preventing
                cross-site request forgery as described in <a class='info' href='#CSRF'>Section&nbsp;10.12<span> (</span><span class='info'>クロスサイトリクエストフォージェリ<!-- Cross-Site Request Forgery --></span><span>)</span></a>.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            The client directs the resource owner to the constructed URI using an HTTP redirection
            response, or by other means available to it via the user-agent.
          
</p>
<p>
              For example, the client directs the user-agent to make the following HTTP request
              using transport-layer security (extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
      &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
  Host: server.example.com

</pre></div>
<p>
            The authorization server validates the request to ensure all required parameters are
            present and valid. The authorization server MUST verify that the redirection URI to which
            it will redirect the access token matches a redirection URI registered by the client as
            described in <a class='info' href='#redirect-uri'>Section&nbsp;3.1.2<span> (</span><span class='info'>リダイレクションエンドポイント</span><span>)</span></a>.
          
</p>
<p>
            If the request is valid, the authorization server authenticates the resource owner and
            obtains an authorization decision (by asking the resource owner or by establishing
            approval via other means).
          
</p>
<p>
            When a decision is established, the authorization server directs the user-agent to the
            provided client redirection URI using an HTTP redirection response, or by other means
            available to it via the user-agent.
          
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Access Token Response</h3>

<p>
            If the resource owner grants the access request, the authorization server issues an
            access token and delivers it to the client by adding the following parameters to
            the fragment component of the redirection URI using the
            <tt>application/x-www-form-urlencoded</tt> format:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>access_token</dt>
<dd>
                
                REQUIRED. The access token issued by the authorization server.
              
</dd>
<dt>token_type</dt>
<dd>
                
                REQUIRED. The type of the token issued as described in
                <a class='info' href='#token-types'>Section&nbsp;7.1<span> (</span><span class='info'>アクセストークンタイプ<!-- Access Token Types --></span><span>)</span></a>. Value is case insensitive.
              
</dd>
<dt>expires_in</dt>
<dd>
                
                OPTIONAL. The lifetime in seconds of the access token. For example, the value
                <tt>3600</tt> denotes that the access token will expire in one
                hour from the time the response was generated.
              
</dd>
<dt>scope</dt>
<dd>
                
                OPTIONAL. The scope of the access token as described by <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>.
              
</dd>
<dt>state</dt>
<dd>
                
                REQUIRED if the <tt>state</tt> parameter was present in the
                client authorization request. The exact value received from the client.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            The authorization server MUST NOT issue a refresh token.
          
</p>
<p>
              For example, the authorization server redirects the user-agent by sending the
              following HTTP response (URI extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 302 Found
  Location: http://example.com/rd#access_token=2YotnFZFEjr1zCsicMWpAA
            &amp;state=xyz&amp;token_type=example&amp;expires_in=3600

</pre></div>
<p>
              Developers should note that some HTTP client implementations do not support the
              inclusion of a fragment component in the HTTP <tt>Location</tt>
              response header field. Such client will require using other methods for redirecting
              the client than a 3xx redirection response. For example, returning an HTML page which
              includes a 'continue' button with an action linked to the redirection URI.
            
</p>
<p>
            The client SHOULD ignore unrecognized response parameters. The access token string size
            is left undefined by this specification. The client should avoid making assumptions
            about value sizes. The authorization server should document the size of any value it
            issues.
          
</p>
<a name="implicit-authz-error"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2.1"></a><h3>4.2.2.1.&nbsp;
Error Response</h3>

<p>
              If the request fails due to a missing, invalid, or mismatching redirection URI, or if
              the client identifier provided is invalid, the authorization server SHOULD inform the
              resource owner of the error, and MUST NOT automatically redirect the user-agent to
              the invalid redirection URI.
            
</p>
<p>
              If the resource owner denies the access request or if the request fails for reasons
              other than a missing or invalid redirection URI, the authorization server informs the
              client by adding the following parameters to the fragment component of the
              redirection URI using the
              <tt>application/x-www-form-urlencoded</tt> format:
            
</p>
<p>
              </p>
<blockquote class="text"><dl>
<dt>error</dt>
<dd>
                  
                  REQUIRED. A single error code from the following:

                  
<blockquote class="text"><dl>
<dt>invalid_request</dt>
<dd>
                      
                      The request is missing a required parameter, includes an unsupported
                      parameter value, or is otherwise malformed.
                    
</dd>
<dt>unauthorized_client</dt>
<dd>
                      
                      The client is not authorized to request an access token using this method.
                    
</dd>
<dt>access_denied</dt>
<dd>
                      
                      The resource owner or authorization server denied the request.
                    
</dd>
<dt>unsupported_response_type</dt>
<dd>
                      
                      The authorization server does not support obtaining an access token using
                      this method.
                    
</dd>
<dt>invalid_scope</dt>
<dd>
                      
                      The requested scope is invalid, unknown, or malformed.
                    
</dd>
<dt>server_error</dt>
<dd>
                      
                      The authorization server encountered an unexpected condition which prevented
                      it from fulfilling the request.
                    
</dd>
<dt>temporarily_unavailable</dt>
<dd>
                      
                      The authorization server is currently unable to handle the request due to a
                      temporary overloading or maintenance of the server.
                    
</dd>
</dl></blockquote>
                
</dd>
<dt>error_description</dt>
<dd>
                  
                  OPTIONAL. A human-readable UTF-8 encoded text providing additional information,
                  used to assist the client developer in understanding the error that occurred.
                
</dd>
<dt>error_uri</dt>
<dd>
                  
                  OPTIONAL. A URI identifying a human-readable web page with information about the
                  error, used to provide the client developer with additional information about the
                  error.
                
</dd>
<dt>state</dt>
<dd>
                  
                  REQUIRED if a valid <tt>state</tt> parameter was present in the
                  client authorization request. The exact value received from the client.
                
</dd>
</dl></blockquote><p>
            
</p>
<p>
                For example, the authorization server redirects the user-agent by sending the
                following HTTP response:
              
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 302 Found
  Location: https://client.example.com/cb#error=access_denied&amp;state=xyz

</pre></div>
<a name="grant-password"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Resource Owner Password Credentials</h3>

<p>
          The resource owner password credentials grant type is suitable in cases where the
          resource owner has a trust relationship with the client, such as its device operating
          system or a highly privileged application. The authorization server should take special
          care when enabling this grant type, and only allow it when other flows are not viable.
        
</p>
<p>
          The grant type is suitable for clients capable of obtaining the resource owner's
          credentials (username and password, typically using an interactive form). It is also used
          to migrate existing clients using direct authentication schemes such as HTTP Basic or
          Digest authentication to OAuth by converting the stored credentials to an access token.
        
</p><br /><hr class="insert" />
<a name="Figure-5"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +----------+
  | Resource |
  |  Owner   |
  |          |
  +----------+
       v
       |    Resource Owner
      (A) Password Credentials
       |
       v
  +---------+                                  +---------------+
  |         |&gt;--(B)---- Resource Owner -------&gt;|               |
  |         |         Password Credentials     | Authorization |
  | Client  |                                  |     Server    |
  |         |&lt;--(C)---- Access Token ---------&lt;|               |
  |         |    (w/ Optional Refresh Token)   |               |
  +---------+                                  +---------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Resource Owner Password Credentials Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          The flow illustrated in <a class='info' href='#Figure-5'>Figure&nbsp;5<span> (</span><span class='info'>Resource Owner Password Credentials Flow</span><span>)</span></a> includes the following steps:
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              The resource owner provides the client with its username and password.
            
</dd>
<dt>(B)</dt>
<dd>
              The client requests an access token from the authorization server's token endpoint by
              including the credentials received from the resource owner. When making the request,
              the client authenticates with the authorization server.
            
</dd>
<dt>(C)</dt>
<dd>
              The authorization server authenticates the client and validates the resource owner
              credentials, and if valid issues an access token.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Authorization Request and Response</h3>

<p>
            The method through which the client obtains the resource owner credentials is beyond
            the scope of this specification. The client MUST discard the credentials once an access
            token has been obtained.
          
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
Access Token Request</h3>

<p>
            The client makes a request to the token endpoint by adding the following parameters
            using the <tt>application/x-www-form-urlencoded</tt> format in the
            HTTP request entity-body:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>grant_type</dt>
<dd>
                
                REQUIRED. Value MUST be set to <tt>password</tt>.
              
</dd>
<dt>username</dt>
<dd>
                
                REQUIRED. The resource owner username, encoded as UTF-8.
              
</dd>
<dt>password</dt>
<dd>
                
                REQUIRED. The resource owner password, encoded as UTF-8.
              
</dd>
<dt>scope</dt>
<dd>
                
                OPTIONAL. The scope of the access request as described by <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            If the client type is confidential or the client was issued client credentials (or
            assigned other authentication requirements), the client MUST authenticate with the
            authorization server as described in <a class='info' href='#token-endpoint-auth'>Section&nbsp;3.2.1<span> (</span><span class='info'>Client Authentication</span><span>)</span></a>.
          
</p>
<p>
              For example, the client makes the following HTTP request using transport-layer
              security (extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=password&amp;username=johndoe&amp;password=A3ddj3w

</pre></div>
<p>
            The authorization server MUST:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                require client authentication for confidential clients or for any client that was
                issued client credentials (or with other authentication requirements),
              
</li>
<li>
                authenticate the client if client authentication is included, and
              
</li>
<li>
                validate the resource owner password credentials.
              
</li>
</ul><p>
          
</p>
<p>
            Since this access token request utilizes the resource owner's password, the
            authorization server MUST protect the endpoint against brute force attacks.
          
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.3"></a><h3>4.3.3.&nbsp;
Access Token Response</h3>

<p>
            If the access token request is valid and authorized, the authorization server issues an
            access token and optional refresh token as described in <a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a>.
            If the request failed client authentication or is invalid, the authorization server returns
            an error response as described in <a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>.
          
</p>
<p>
              An example successful response:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
  }

</pre></div>
<a name="grant-client"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Client Credentials</h3>

<p>
          The client can request an access token using only its client credentials (or other
          supported means of authentication) when the client is requesting access to the
          protected resources under its control, or those of another resource owner which has been
          previously arranged with the authorization server (the method of which is beyond the
          scope of this specification).
        
</p>
<p>
          The client credentials grant type MUST only be used by confidential clients.
        
</p><br /><hr class="insert" />
<a name="Figure-6"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  +---------+                                  +---------------+
  |         |                                  |               |
  |         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
  | Client  |                                  |     Server    |
  |         |&lt;--(B)---- Access Token ---------&lt;|               |
  |         |                                  |               |
  +---------+                                  +---------------+

</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Client Credentials Flow&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
          The flow illustrated in <a class='info' href='#Figure-6'>Figure&nbsp;6<span> (</span><span class='info'>Client Credentials Flow</span><span>)</span></a> includes the following steps:
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>(A)</dt>
<dd>
              The client authenticates with the authorization server and requests an access token
              from the token endpoint.
            
</dd>
<dt>(B)</dt>
<dd>
              The authorization server authenticates the client, and if valid issues an access
              token.
            
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
Authorization Request and Response</h3>

<p>
            Since the client authentication is used as the authorization grant, no additional
            authorization request is needed.
          
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.2"></a><h3>4.4.2.&nbsp;
Access Token Request</h3>

<p>
            The client makes a request to the token endpoint by adding the following parameters
            using the <tt>application/x-www-form-urlencoded</tt> format in the
            HTTP request entity-body:
          
</p>
<p>
            </p>
<blockquote class="text"><dl>
<dt>grant_type</dt>
<dd>
                
                REQUIRED. Value MUST be set to <tt>client_credentials</tt>.
              
</dd>
<dt>scope</dt>
<dd>
                
                OPTIONAL. The scope of the access request as described by <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>.
              
</dd>
</dl></blockquote><p>
          
</p>
<p>
            The client MUST authenticate with the authorization server as described in
            <a class='info' href='#token-endpoint-auth'>Section&nbsp;3.2.1<span> (</span><span class='info'>Client Authentication</span><span>)</span></a>.
          
</p>
<p>
              For example, the client makes the following HTTP request using transport-layer
              security (extra line breaks are for display purposes only):
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=client_credentials

</pre></div>
<p>
            The authorization server MUST authenticate the client.
          
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.3"></a><h3>4.4.3.&nbsp;
Access Token Response</h3>

<p>
            If the access token request is valid and authorized, the authorization server issues an
            access token as described in <a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a>. A refresh token SHOULD
            NOT be included. If the request failed client authentication or is invalid, the
            authorization server returns an error response as described in
            <a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>.
          
</p>
<p>
              An example successful response:
            
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "example_parameter":"example_value"
  }

</pre></div>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Extensions</h3>

<p>
          The client uses an extension grant type by specifying the grant type using an
          absolute URI (defined by the authorization server) as the value of the
          <tt>grant_type</tt> parameter of the token endpoint, and by
          adding any additional parameters necessary.
        
</p>
<p>
            For example, to request an access token using a SAML 2.0 assertion grant type as
            defined by <a class='info' href='#I-D.ietf-oauth-saml2-bearer'>[I&#8209;D.ietf&#8209;oauth&#8209;saml2&#8209;bearer]<span> (</span><span class='info'>Mortimore, C., &ldquo;SAML 2.0 Bearer Assertion Profiles for OAuth 2.0,&rdquo; August&nbsp;2011.</span><span>)</span></a>, the client makes the
            following HTTP request using transport-layer security (line breaks are for display
            purposes only):
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
  bearer&amp;assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
  [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-

</pre></div>
<p>
          If the access token request is valid and authorized, the authorization server issues an
          access token and optional refresh token as described in <a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a>.
          If the request failed client authentication or is invalid, the authorization server returns
          an error response as described in <a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>.
        
</p>
<a name="token-issue"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
アクセストークンの発行<!-- Issuing an Access Token --></h3>

<p>
        アクセストークンリクエストが正当であり認可済であれば, 認可サーバーは <a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a> に述べる形式でアクセストークン (および任意でリフレッシュトークン) を発行する.
        クライアント認証に失敗したりリクエストが不正であった場合は, 認可サーバーは <a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a> に述べる形式でエラーレスポンスを返す.
        
      
</p>
<a name="token-response"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
成功レスポンス<!-- Successful Response --></h3>

<p>
          認可サーバーはアクセストークン (および任意でリフレッシュトークン) を発行する.
          このレスポンスはエンティティーボディーに以下のパラメーターを含み, HTTP ステータスコード 200 (OK) で返される.
          
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>access_token</dt>
<dd>
              
              必須 (REQUIRED).
              認可サーバーが発行するアクセストークン.
              
            
</dd>
<dt>token_type</dt>
<dd>
              
              必須 (REQUIRED).
              トークンのタイプ.
              値は大文字・小文字を区別しない.
              詳細は <a class='info' href='#token-types'>Section&nbsp;7.1<span> (</span><span class='info'>アクセストークンタイプ<!-- Access Token Types --></span><span>)</span></a> で述べる.
              
            
</dd>
<dt>expires_in</dt>
<dd>
              
              任意 (OPTIONAL).
              アクセストークンの有効期間を表す秒数.
              例えばこの値が <tt>3600</tt> であれば, そのアクセストークンは発行から1時間後に期限切れとなる.
              
            
</dd>
<dt>refresh_token</dt>
<dd>
              
              任意 (OPTIONAL).
              リフレッシュトークン.
              同じアクセス許可を用いて新しいアクセストークンを取得するのに利用される.
              詳細は <a class='info' href='#token-refresh'>Section&nbsp;6<span> (</span><span class='info'>アクセストークンの更新<!--Refreshing an Access Token--></span><span>)</span></a> で述べる.
              
            
</dd>
<dt>scope</dt>
<dd>
              
              任意 (OPTIONAL).
              アクセストークンのスコープ.
              詳細は <a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a> で述べる.
              
            
</dd>
</dl></blockquote><p>
        
</p>
<p>
          これらのパラメーターは, <a class='info' href='#RFC4627'>[RFC4627]<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> で定義されているメディアタイプ <tt>application/json</tt> 形式で, HTTPレスポンスボディーに含まれる.
          JSONへのシリアライゼーションは, 各パラメーターをJSONオブジェクトの最上位要素とする形式で行う.
          パラメーター名と文字列値はJSON文字列, 数値はJSON数値となる.
          パラメーターの順序は問わず, 多様であり得る.
          
        
</p>
<p>
          認可サーバーは, トークン, クレデンシャル, その他センシティブな情報を含むいかなる HTTP レスポンスにおいても, <tt>Cache-Control</tt> (<a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>) ヘッダーに <tt>no-store</tt> を, <tt>Pragma</tt> (<a class='info' href='#RFC2616'>[RFC2616]<span> (</span><span class='info'>Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, &ldquo;Hypertext Transfer Protocol -- HTTP/1.1,&rdquo; June&nbsp;1999.</span><span>)</span></a>) ヘッダーに <tt>no-cache</tt> を指定しなければならない (MUST).
          
        
</p>
<p>
            例:
            
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 200 OK
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"example",
    "expires_in":3600,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "example_parameter":"example_value"
  }

</pre></div>
<p>
          クライアントは認識できないレスポンスパラメーターを無視するべきである (SHOULD).
          トークンや認可サーバーから受けとるその他の値のサイズは定義しない.
          クライアントは値のサイズについてなんらかの仮定をすべきではない.
          認可サーバーは自身が発行するあらゆる値のサイズについて明記すべきである.
          
        
</p>
<a name="token-errors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
エラーレスポンス<!-- Error Response --></h3>

<p>
          認可サーバーはHTTP ステータスコード 400 (Bad Request) を返す.
          このレスポンスには以下のパラメーターが含まれる.
          
        
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>error</dt>
<dd>
              
              必須 (REQUIRED).
              以下のエラーコードより1つを設定する.
              
              
<blockquote class="text"><dl>
<dt>invalid_request</dt>
<dd>
                  
                  リクエストに必要なパラメーターが含まれていない, サポートされないパラメーター値が含まれている, パラメーターが重複している, 複数のクレデンシャルが含まれている, クライアント認証のための複数のメカニズムが利用されている, もしくは異常値が設定されている.
                  
                
</dd>
<dt>invalid_client</dt>
<dd>
                  
                  クライアント認証に失敗した (例えば未知のクライアントやクライアント認証がされていない, もしくはサポートされない認証方式).
                  認可サーバーはHTTP認証スキームがサポートされていないことを示すためにHTTP ステータスコード 401 (Unauthorized) を返してもよい (MAY).
                  もしクライアントが <tt>Authorization</tt> リクエストヘッダー経由で認証を試みた場合, 認可サーバーはHTTP ステータスコード 401 (Unauthorized) と共に, <tt>WWW-Authenticate</tt> レスポンスヘッダーにクライアントが利用すべき認証スキームを含めなければならない (MUST).
                  
                
</dd>
<dt>invalid_grant</dt>
<dd>
                  
                  提供されたアクセス許可 (例えば認可コード, リソースオーナークレデンシャル, クライアントクレデンシャル) が不正, 有効期限切れ, 失効している, 認可要求の中のリダイレクト先URIとマッチしていない, 他のクライアントに対して発行されたものである.
                  
                
</dd>
<dt>unauthorized_client</dt>
<dd>
                  
                  認証されたクライアントが当該の grant_type を利用する様に認可されていない.
                  
                
</dd>
<dt>unsupported_grant_type</dt>
<dd>
                  
                  grant_type が認可サーバーによってサポートされていない.
                  
                
</dd>
<dt>invalid_scope</dt>
<dd>
                  
                  要求された scope が不正, 未知, 異常, リソースオーナーによって与えられた範囲を超えている.
                  
                
</dd>
</dl></blockquote>
            
</dd>
<dt>error_description</dt>
<dd>
              
              任意 (OPTIONAL).
              クライアント開発者が発生したエラーを理解しやすくするためのUTF-8でエンコードされた可読性のある追加情報.
              
            
</dd>
<dt>error_uri</dt>
<dd>
              
              任意 (OPTIONAL).
              クライアント開発者に発生したエラーに関する追加情報を提供する可読性のある情報が記載されているウェブページのURI.
              
            
</dd>
</dl></blockquote><p>
        
</p>
<p>
          これらのパラメーターは, <a class='info' href='#RFC4627'>[RFC4627]<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> で定義されているメディアタイプ <tt>application/json</tt> 形式で, HTTPレスポンスボディーに含まれる.
          JSONへのシリアライゼーションは, 各パラメーターをJSONオブジェクトの最上位要素とする形式で行う.
          パラメーター名と文字列値はJSON文字列, 数値はJSON数値となる.
          パラメーターの順序は問わず, 多様であり得る.
          
        
</p>
<p>
            例:
            
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  HTTP/1.1 400 Bad Request
  Content-Type: application/json;charset=UTF-8
  Cache-Control: no-store
  Pragma: no-cache

  {
    "error":"invalid_request"
  }

</pre></div>
<a name="token-refresh"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
アクセストークンの更新<!--Refreshing an Access Token--></h3>

<p>
	  認可サーバーがクライアントにリフレッシュトークンを発行していれば, クライアントはトークンエンドポイントに更新リクエストを送ることができる.
	  以下のパラメータが<tt>application/x-www-form-urlencoded</tt>形式でHTTPリクエストエンティティーボディーに加えられる.
	  
      
</p>
<p>
        </p>
<blockquote class="text"><dl>
<dt>grant_type</dt>
<dd>
            
			必須 (REQUIRED).
			値には<tt>refresh_token</tt>がセットされなければならない (MUST).
			
          
</dd>
<dt>refresh_token</dt>
<dd>
            
			必須 (REQUIRED).
			クライアントに発行されたリフレッシュトークン.
			
          
</dd>
<dt>scope</dt>
<dd>
            
			任意 (OPTIONAL).
			アクセス要求のスコープ.
			詳細は<a class='info' href='#scope'>Section&nbsp;3.3<span> (</span><span class='info'>Access Token Scope</span><span>)</span></a>で述べる.
			要求されたスコープはリソースオーナーがもともと許可していない値を含んではならない (MUST NOT).
			もし指定されなかった場合は, もともと許可された値として扱われる.
			
          
</dd>
</dl></blockquote><p>
      
</p>
<p>
	  リフレッシュトークンは一般的にアクセストークンの要求に用いる永続的なクレデンシャルであるため, 発行されたクライアントと紐づく.
	  クライアントタイプがconfidential, もしくはクライアントクレデンシャルが発行された(もしくは他の認証が要求された)クライアントは, 認可サーバーにより認証されなければならない (MUST).
	  クライアント認証は<a class='info' href='#token-endpoint-auth'>Section&nbsp;3.2.1<span> (</span><span class='info'>Client Authentication</span><span>)</span></a>で述べる.
	  
      
</p>
<p>
		例えば, クライアントは以下のHTTPリクエストをセキュリティ保護されたトランスポート層から送信する (改行は掲載上の都合による).
		
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  POST /token HTTP/1.1
  Host: server.example.com
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
  Content-Type: application/x-www-form-urlencoded;charset=UTF-8

  grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA

</pre></div>
<p>
	  認可サーバーは次のことを実施しなければならない (MUST):
	  
      
</p>
<p>
        </p>
<ul class="text">
<li>
		  confidentialなクライアント, もしくはクライアントクレデンシャルが発行された(もしくは他の認証が要求された)クライアントにクライアント認証を要求し, 
		  
          
</li>
<li>
		  クライアント認証に必要な情報が含まれ, リフレッシュトークンが認証されたクライアントに発行されたことが保証された時にクライアントを認証し, 
		  
          
</li>
<li>
		  リフレッシュトークンを検証する.
		  
          
</li>
</ul><p>
      
</p>
<p>
	  リクエストが有効で認可された場合, 認可サーバーはアクセストークンを発行する.
	  レスポンスの詳細は<a class='info' href='#token-response'>Section&nbsp;5.1<span> (</span><span class='info'>成功レスポンス<!-- Successful Response --></span><span>)</span></a>で述べる.
	  リクエストの確認に失敗もしくはリクエストが無効な場合, 認可サーバーはエラーレスポンスを返す.
	  エラーレスポンスの詳細は<a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>で述べる.
	  
      
</p>
<p>
	  認可サーバーは新しいリフレッシュトークンを返してもよい (MAY).
	  その時, クライアントは古いリフレッシュトークンを破棄し, 新しいリフレッシュトークンに取り替える.
	  認可サーバーは新しいリフレッシュトークンを発行した後, 古いリフレッシュトークンを無効化してもよい (MAY).
	  新しいリフレッシュトークンが発行された時, リフレッシュトークンのスコープはクライアントによってリクエストに含まれたリフレッシュトークンのスコープと同一でなければならない(MUST).
	  
      
</p>
<a name="access-resource"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
保護対象リソースへのアクセス<!-- Accessing Protected Resources --></h3>

<p>
        クライアントはリソースサーバー上の保護されたリソースにアクセストークンを用いてアクセスする.リソースサーバーはアクセストークンの検証を行い, 有効期間が切れていないこと, 要求されているリソースがスコープの範囲内であることを確認しなければならない(MUST).アクセストークンを検証する具体的な方法は本仕様の対象外だが, 一般的に検証はリソースサーバーと認可サーバーで協調して実行される.
      
      
</p>
<p>
        クライアントがリソースサーバーの認証を受けるためにどのようにアクセストークンを用いるかは, リソースサーバーから払い出されたアクセストークンタイプに依存する.一般的には, アクセストークンタイプの仕様に定義される認証スキームに従ってHTTPの <tt>Authorization</tt> ヘッダフィールド <a class='info' href='#RFC2617'>[RFC2617]<span> (</span><span class='info'>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, &ldquo;HTTP Authentication: Basic and Digest Access Authentication,&rdquo; June&nbsp;1999.</span><span>)</span></a> が利用される.
      
      
</p>
<a name="token-types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
アクセストークンタイプ<!-- Access Token Types --></h3>

<p>
          アクセストークンタイプにより, クライアントは保護対象リソースへの（型指定属性込みの）リクエスト時にアクセストークンを利用するために必要な情報を特定することができる.クライアントはトークンタイプが想定外のものであるとき, または信頼できない時にはそのアクセストークンを利用するべきではない(MUST NOT).
        
        
</p>
<p>
            例えば, <a class='info' href='#I-D.ietf-oauth-v2-bearer'>[I&#8209;D.ietf&#8209;oauth&#8209;v2&#8209;bearer]<span> (</span><span class='info'>Jones, M., Hardt, D., and D. Recordon, &ldquo;The OAuth 2.0 Protocol: Bearer Tokens,&rdquo; July&nbsp;2011.</span><span>)</span></a>に定義される<tt>bearer</tt>トークンタイプは, 単にリクエストにアクセストークンを含めることで利用できる.
        
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: Bearer 7Fjfp0ZBr1KtDRbnfVdmIw

</pre></div>
<p>
            一方, <a class='info' href='#I-D.ietf-oauth-v2-http-mac'>[I&#8209;D.ietf&#8209;oauth&#8209;v2&#8209;http&#8209;mac]<span> (</span><span class='info'>Hammer-Lahav, E., Barth, A., and B. Adida, &ldquo;HTTP Authentication: MAC Access Authentication,&rdquo; May&nbsp;2011.</span><span>)</span></a>に定義される<tt>mac</tt>トークンタイプは, アクセストークンと共にMacキーをリクエストに含めて利用できる.このMackキーはHTTPリクエストの一部分を署名するのに利用される.
        
          
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  GET /resource/1 HTTP/1.1
  Host: example.com
  Authorization: MAC id="h480djs93hd8",
                     nonce="274312:dj83hs9s",
                     mac="kDZvddkndxvhGRXZhvuDjEWhGeE="

</pre></div>
<p>
          尚, 上記はあくまで参考例であり, 開発者は利用前に<a class='info' href='#I-D.ietf-oauth-v2-bearer'>[I&#8209;D.ietf&#8209;oauth&#8209;v2&#8209;bearer]<span> (</span><span class='info'>Jones, M., Hardt, D., and D. Recordon, &ldquo;The OAuth 2.0 Protocol: Bearer Tokens,&rdquo; July&nbsp;2011.</span><span>)</span></a>や<a class='info' href='#I-D.ietf-oauth-v2-http-mac'>[I&#8209;D.ietf&#8209;oauth&#8209;v2&#8209;http&#8209;mac]<span> (</span><span class='info'>Hammer-Lahav, E., Barth, A., and B. Adida, &ldquo;HTTP Authentication: MAC Access Authentication,&rdquo; May&nbsp;2011.</span><span>)</span></a>を参照することが推奨される.
        
        
</p>
<p>
          アクセストークンタイプでは, 必要な場合には<tt>access_token</tt>レスポンス属性と共にクライアントに送り返す追加属性を定義することができる.また, 保護対象リソースへのリクエストにアクセストークンを含めるために利用されるHTTP認証方式も定義される.
        
        
</p>
<a name="extensions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
仕様の拡張性<!-- Extensibility --></h3>

<a name="new-types"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
アクセストークンタイプの定義<!-- Defining Access Token Types --></h3>

<p>
          アクセストークンタイプを定義する方法は, <a class='info' href='#type-registry'>Section&nbsp;11.1<span> (</span><span class='info'>The OAuth Access Token Type Registry</span><span>)</span></a> に示す手順でアクセストークンタイプレジストリーへの登録を行う方法と, 重複しない絶対 URI をタイプ名として用いる方法の2通りが存在する.
          
        
</p>
<p>
          URI をタイプ名として用いるトークンタイプは, ベンダー固有の実装に限定されるべきであり (SHOULD), 広く一般に適用されるものではない.
          またこれらのトークンタイプは, それが用いられるリソースサーバーの実装詳細に固有のものである.
          
        
</p>
<p>
          上記以外のすべてのトークンタイプは, レジストリへの登録が必須である (MUST).
          タイプ名は type-name ABNF に従わなければならない (MUST).
          またトークンタイプが新しい HTTP 認証スキームを定義する場合, そのタイプ名には (<a class='info' href='#RFC2617'>[RFC2617]<span> (</span><span class='info'>Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, &ldquo;HTTP Authentication: Basic and Digest Access Authentication,&rdquo; June&nbsp;1999.</span><span>)</span></a> に定義されるように) HTTP 認証スキームと同一のものを用いるべきである (SHOULD).
          なおトークンタイプ <tt>example</tt> は, 例示のために予約済である.
          
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  type-name  = 1*name-char
  name-char   = "-" / "." / "_" / DIGIT / ALPHA

</pre></div>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
新たなエンドポイントパラメーターの定義<!-- Defining New Endpoint Parameters --></h3>

<p>
          認可エンドポイントおよびトークンエンドポイントで用いられる新たなリクエストないしレスポンスパラメーターは, <a class='info' href='#parameters-registry'>Section&nbsp;11.2<span> (</span><span class='info'>The OAuth Parameters Registry</span><span>)</span></a> に示す手順に従って定義され, パラメーターレジストリーに登録される.
          
        
</p>
<p>
          パラメーター名は param-name ABNF に従わなければならず (MUST), パラメーター値は (ABNF や既存パラメーターのシンタックスを参照するなどの方法で) 明確に定義する必要がある (MUST).
          
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  param-name  = 1*name-char
  name-char   = "-" / "." / "_" / DIGIT / ALPHA

</pre></div>
<p>
          ベンダー固有の未登録拡張パラメーターは, 広く一般には適用されず, それが用いられる認可サーバーの実装詳細に固有のものである.
          これらの拡張パラメーターには, その他の登録済みの値と衝突しないようなベンダー固有のプレフィックスを用いるべきである. (例: パラメーター名を 'companyname_' で始める)
          
        
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
新たな認可グラントタイプの定義<!-- Defining New Authorization Grant Types --></h3>

<p>
          新たな認可グラントタイプは <tt>grant_type</tt> パラメーター値として用いる重複の無い絶対 URI を用いることで定義される.
          拡張グラントタイプを用いるために新たなトークンエンドポイントパラメーターが必要な場合は, それらのパラメーターを <a class='info' href='#parameters-registry'>Section&nbsp;11.2<span> (</span><span class='info'>The OAuth Parameters Registry</span><span>)</span></a> に述べるように OAuth パラメーターレジストリーに登録する必要がある (MUST).
          
        
</p>
<a name="response-type-ext"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
新たな認可エンドポイントレスポンスタイプの定義<!-- Defining New Authorization Endpoint Response Types --></h3>

<p>
          認可エンドポイントで利用される新しいレスポンスタイプは認可エンドポイントレスポンスタイプレジストリーに <a class='info' href='#response-type-registry'>Section&nbsp;11.3<span> (</span><span class='info'>The OAuth Authorization Endpoint Response Type Registry</span><span>)</span></a> の手順で定義され登録される. レスポンスタイプ名は response-type ABNF に従って定義する必要がある (MUST).
          
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  response-type  = response-name *( SP response-name )
  response-name  = 1*response-char
  response-char  = "_" / DIGIT / ALPHA

</pre></div>
<p>
          レスポンスタイプが一つ以上の空白文字 (%x20) を含む場合, それは空白で区切られた順不同の値のリストとして扱われる. 値の順番は一通りだけ登録でき, 同じ値の組の順番を変えた他のすべての組み合わせを網羅する.
          
        
</p>
<p>
          例えば, 本仕様ではレスポンスタイプ <tt>token code</tt> を定義しないが, 拡張仕様として <tt>token code</tt> レスポンスタイプを定義し登録することは可能である. 一旦登録されると同じ組み合わせは <tt>code token</tt> としては登録することはできないが, 両方の値は同じレスポンスタイプを示すために使うことが出来る.
          
        
</p>
<a name="new-errors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.5"></a><h3>8.5.&nbsp;
追加のエラーコードの定義<!-- Defining Additional Error Codes --></h3>

<p>
          プロトコルの拡張 (例えば, アクセストークンタイプ, 拡張パラメーター, 拡張グラントタイプ) が認可コードグラントエラーレスポンス (<a class='info' href='#code-authz-error'>Section&nbsp;4.1.2.1<span> (</span><span class='info'>Error Response</span><span>)</span></a>), implicit grant エラーレスポンス (<a class='info' href='#implicit-authz-error'>Section&nbsp;4.2.2.1<span> (</span><span class='info'>Error Response</span><span>)</span></a>), トークンエラーレスポンス (<a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>) と一緒に使われる追加のエラーコードを必要とする場合, そのようなエラーコードを定義してもよい (MAY).
          
        
</p>
<p>
          拡張エラーコードは登録されたアクセストークンタイプ, エンドポイントパラメータ, 拡張グラントタイプと共に利用する場合は (<a class='info' href='#error-registry'>Section&nbsp;11.4<span> (</span><span class='info'>The OAuth Extensions Error Registry</span><span>)</span></a> の手順に従って) 登録されなければならない (MUST). 登録されていない拡張と共に利用するエラーコードは登録してもよい (MAY).
          
        
</p>
<p>
          エラーコードは error-code ABNF に従う必要があり (MUST), 可能な場合は識別名をプレフィックスとして付与するべきである (SHOULD). 例えば, 不正な値が拡張パラメーター  <tt>example</tt> に設定されたことを示すエラーは <tt>example_invalid</tt> と命名されるべきである.
          
        
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

  error-code   = ALPHA *error-char
  error-char   = "-" / "." / "_" / DIGIT / ALPHA

</pre></div>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
ネイティブアプリケーション<!--Native Applications--></h3>

<p>
	  ネイティブアプリケーションはリソースオーナーの端末にインストールされ, 実行されるクライアントである(例えば, デスクトップアプリケーション, ネイティブモバイルアプリケーション).
	  ネイティブアプリケーションではセキュリティ, プラットフォーム性能と全体的なエンドユーザー経験に関する特別な考慮を必要とするかもしれない(MAY).
	  
      
</p>
<p>
	  認可エンドポイントはクライアントとリソースオーナーのユーザーエージェントによるインタラクションを要求する.
	  ネイティブアプリケーションは外部のユーザーエージェントを起動もしくはアプリケーション内にユーザーエージェントを埋め込むことができる.
	  
      
</p>
<p>
        </p>
<ul class="text">
<li>
		  外部のユーザーエージェント - ネイティブアプリケーションは, クライアントを起動するためのハンドラとしてオペレーションシステムに登録したスキームをリダイレクトURIにして利用する, クレデンシャルをコピーアンドペーストする, ローカルのウェブサーバーを利用する, ユーザーエクステンションをインストールする, クライアントの管理下にあるサーバ上のリソースをリダイレクトURIとして利用するなど, ネイティブアプリケーションがレスポンスにアクセスすることを可能にする手段を用いて, 認可サーバーからのレスポンスを取得することができる.
	  
          
</li>
<li>
		  埋め込まれたユーザーエージェント - ネイティブアプリケーションは, リソースを読み込んでいる間に発生した状態変更の監視やユーザーエージェントのクッキーストレージへのアクセスなど, 埋め込まれたユーザーエージェントとの直接通信によりレスポンスを受け取ることができる.
		    
          
</li>
</ul><p>
      
</p>
<p>
	  外部のユーザーエージェントか埋め込みのユーザーエージェントかを選択するとき, 開発者は以下のことを考慮すべきである.
	  
      
</p>
<p>
        </p>
<ul class="text">
<li>
            認可サーバーが再認証を要求しない仕様になっており, かつリソースオーナーがアクティブセッションを保有している場合, 外部のユーザーエージェントは完了率をあげるかもしれない.
            それはおなじみのエンドユーザー体験と機能性を提供する.
            リソースオーナーはまた認証を手助けするユーザーエージェントの機能や拡張(パスワードマネージャ, 2要素のリーダー装置)に頼ることができる.
            
          
</li>
<li>
            埋め込みのユーザーエージェントはコンテキストの切り替えと新しいウィンドウオープンを取り除くことで, ユーザービリティを向上させることができるかもしれない.
            
          
</li>
<li>
            リソースオーナーはほとんどの外部ユーザーエージェントで見られる視覚的な保護機能にアクセスすることなく未確認のウィンドウ内で認証するため, 埋め込みのユーザーエージェントはセキュリティ問題を引き起こす.
            埋め込みのユーザーエージェントは (フィッシング攻撃が簡単に実行できる) 未確認の認証要求を信用するようエンドユーザーに教育してしまう.
            
          
</li>
</ul><p>
      
</p>
<p>
        インプリシットグラントタイプと認可コードグラントタイプを選択するとき, 以下について考慮すべきである.
        
      
</p>
<p>
        </p>
<ul class="text">
<li>
            ネイティブアプリケーションはその性質上クライアントクレデンシャルを秘匿に保てないため, 認可コードグラントタイプを利用するネィティブアプリケーションはクライアントクレデンシャルを使うべきではない(SHOULD).
            
          
</li>
<li>
            インプリシットグラントタイプのフローを利用すると, リフレッシュトークンは返されないため, アクセストークンの期限が切れるたびに認可プロセスを繰り返す必要がある.
            
          
</li>
</ul><p>
      
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p>
        柔軟で拡張可能なフレームワークとして, OAuthでセキュリティに関して配慮すべき点は多くの因子によって決まる. 以下のセクションでは実装者に<a class='info' href='#client-types'>Section&nbsp;2.1<span> (</span><span class='info'>クライアントタイプ</span><span>)</span></a>にある, webアプリケーション, user-agentベースアプリケーション, ネイティブアプリケーションの３つのクライアントプロファイルにフォーカスを当てたセキュリティガイドラインを提供する.
      
      
</p>
<p>
        完全なOAuthのセキュリティモデルとその分析は, プロトコルデザインの背景と共に<a class='info' href='#I-D.ietf-oauth-v2-threatmodel'>[I&#8209;D.ietf&#8209;oauth&#8209;v2&#8209;threatmodel]<span> (</span><span class='info'>Lodderstedt, T., McGloin, M., and P. Hunt, &ldquo;OAuth 2.0 Threat Model and Security Considerations,&rdquo; July&nbsp;2011.</span><span>)</span></a>で提供される.
      
      
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.1"></a><h3>10.1.&nbsp;
クライアント認証<!--Client Authentication--></h3>

<p>
          認可サーバーはクライアント認証の目的でwebアプリケーションとの間で認証情報を確立する. 認可サーバーはクライアントパスワードより強度の高い認証手段を検討することが推奨される. Webアプリケーションはクライアントパスワードやクレデンシャルの機密性を保持しなければならない(MUST).
        
        
</p>
<p>
          認可サーバーはクライアント認証の目的でネイティブアプリケーションやuser-agentを利用したアプリケーションにパスワードや他のクレデンシャルを発行するべきではありません(MUST NOT). 認証サーバーは特定デバイス上に特化してインストールされたネイティブアプリケーションに対しては, クライアントパスワード, もしくはその他のクレデンシャルを発行するかもしれません(MAY).
        
        
</p>
<p>
          クライアント認証が不可能な時には, 認可サーバーはクライアントのアイデンティティ認証のために他の手段を採用すべきです(SHOULD). 例えば, クライアントのリダイレクトURIの登録要求やリソース所有者によるアイデンティティ確認などです. エンドユーザーの認可時のクライアント認証ではリダイレクトURIの確認だけでは不十分ですが, エンドユーザの認可取得後に偽のクライアントにクレデンシャルを配布するのを回避するのに利用することができる.
        
        
</p>
<p>
          認可サーバーは認証されていないクライアントとの通信によるセキュリティ影響を考慮しなけれならない. そして, そのようなクライアントに対するフレッシュトークンなどの他のクレデンシャルの開示を制限するための措置をとらなければならない.
        
        
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.2"></a><h3>10.2.&nbsp;
クライアント偽装<!-- Client Impersonation --></h3>

<p>
          もし正当なクライアントがクライアントクレデンシャルを秘匿に保てない場合, 悪意あるクライアントがそのクライアントになりすまし, 保護されたリソースへのアクセスを取得することができる.
          
        
</p>
<p>
          認可サーバーはクライアントが認証可能である場合は, 常にクライアント認証を実行しなければならない (MUST).
          クライアントが本質的に認証不可能な場合は, 認可サーバーは認可レスポンス時に用いられる全リダイレクト URI の登録を要求しなければならず (MUST), また上記のような悪意あるクライアントからリソースオーナーを保護する何らかの方策を取るべきである (SHOULD).
          そのような方策の例としては, リソースオーナー自身がクライアントの身元を確認するように認可サーバーが促すことなどが考えられる.
          
        
</p>
<p>
          認可サーバーは明示的にリソースオーナーに認証を要求し, クライアントと要求される認可スコープおよび有効期間についての情報を提供するべきである (SHOULD).
          その時点でのクライアントのコンテキスト内の情報を評価し, リクエストの認可/拒否を行うことは, リソースオーナー自身の判断にゆだねられる.
          
        
</p>
<p>
          認可サーバーは, クライアント認証やその他の判断基準によって, リクエストが同一のクライアントから送られておりクライアント偽装が行われていないことを確認できない限り, 二度目以降の認可リクエストを (リソースオーナーの能動的なインタラクション無しに) 自動的に処理すべきではない (SHOULD NOT).
          
        
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.3"></a><h3>10.3.&nbsp;
アクセストークン<!-- Access Tokens --></h3>

<p>
          アクセストークン (およびあらゆるトークンタイプ固有属性) は, 通信経路・ストレージ上ともに機密に保たれなければならない (MUST).
          またそれらの情報は, 認可サーバー, アクセストークンが通用するリソースサーバー, およびアクセストークンを発行されたクライアントの間でのみ共有される (MUST).
          
        
</p>
<p>
          implicit grant を利用する場合, アクセストークンは URI フラグメント経由で送信されるため, 認可対象外の何者かに漏洩する可能性がある.
          
        
</p>
<p>
          認可サーバーは, 認可対象外の何者かがトークンの有効性を保持したままアクセストークンを生成・変更したり, トークンの生成方法を推測したりできないことを保証しなければならない (MUST).
          
        
</p>
<p>
          クライアントは, 必要最小限のスコープおよび有効期間のアクセストークンを要求すべきである (SHOULD).
          認可サーバーは, 要求されたスコープおよび有効期間をどのように受け入れるかを判断する際, クライアントのアイデンティティーを考慮すべきであり (SHOULD), 場合によっては要求よりも狭い権限しか持たないアクセストークンを発行することもある (MAY).
          
        
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.4"></a><h3>10.4.&nbsp;
リフレッシュトークン<!-- Refresh Tokens --></h3>

<p>
          認可サーバはWebアプリケーションクライアントおよびネイティブアプリケーションクライアントに対してリフレッシュトークンを発行してもよい (MAY).
          
        
</p>
<p>
          リフレッシュトークンは通信経路・ストレージ上ともに機密に保たれ, 認可サーバとリフレッシュトークンの発行先のクライアントの間のみで共有されなければならない (MUST).
          
        
</p>
<p>
          認可サーバはクライアントのアイデンティティを認証出来る場合は常に, リフレッシュトークンとクライアントのアイデンティティとの間のバインディングを検証しなければならない (MUST). クライアント認証が不可能な場合は, 認可サーバはリフレッシュトークンの悪用を防ぐための他の手段を展開すべきである (SHOULD).
          
        
</p>
<p>
          例えば, 認可サーバはアクセストークンリフレッシュレスポンスの都度新しいリフレッシュトークンを発行するリフレッシュトークンローテーションを採用することができる. 前回のリフレッシュトークンは無効にされるが, 認可サーバには残される. もしリフレッシュトークンが漏洩しアタッカーと正当なクライアントの両方によって引き続き利用された場合, それらのうちの一つは無効なリフレッシュトークンを提示し, 認可サーバへ違反の発生を知らせることとなる.
          
        
</p>
<p>
          認可サーバーは, 認可対象外の何者かがトークンの有効性を保持したままリフレッシュトークンを生成・変更したり, トークンの生成方法を推測したりできないことを保証しなければならない (MUST).
          
        
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.5"></a><h3>10.5.&nbsp;
認可コード<!-- Authorization Codes --></h3>

<p>
          認可コードの伝送経路はセキュアなチャネル上で実施されるべき (SHOULD) であり, クライアントはリダイレクトURIがネットワーク上のリソースを指している場合, そのURIを利用するためにTLSを導入すべきである (SHOULD). 認可コードを機密にしておくために努力がなされるべきである. なぜなら認可コードはユーザーエージェントリダイレクトによって伝送されるため, ユーザーエージェントの履歴とHTTPリファラーヘッダーを通して公開されてしまう可能性があるためである.
          
        
</p>
<p>
          認可コードはプロセスを完了するために, 認可サーバーで権限を付与したリソースオーナーがクライアントへ返却されるリソースオーナーと同じであることを確認するために利用されるプレーンテキストの可搬クレデンシャルとして動作する. したがって, もしクライアントが自身のリソースオーナー認証を認可コードに依存する場合は, クライアントのリダイレクトエンドポイントはTLSを必要としなければならない (MUST).
          
        
</p>
<p>
          認可コードの有効期間は短く, かつ一度限りしか利用されてはならない (MUST). もし認可サーバが単一の認可コードをアクセストークンへ交換しようとする複数の試行を検出したならば, 認可サーバはその認可コードに基づき既に付与されたすべてのアクセストークンを無効化することを試みるべきである (SHOULD).
          
        
</p>
<p>
          もしクライアントが認証可能であれば, 認可サーバはその認可コードが同じクライアントに対して発行されたことを確認するためにそのクライアントを認証しなければならない (MUST).
          
        
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.6"></a><h3>10.6.&nbsp;
認可コードリダイレクトURIの操作<!--Authorization Code Redirection URI Manipulation--></h3>

<p>
          認可要求に認可コードグラントタイプを用いるとき, クライアントは<tt>redirect_uri</tt>パラメータによりリダイレクトURIを指定できる. 
          攻撃者がリダイレクトURIの値を操作可能であるとき, 認可サーバーによってリソースオーナーのユーザーエージェントを認可コードを含んだ攻撃者の管理下にあるURIにリダイレクトさせることができる.
          
        
</p>
<p>
          攻撃者は, 正しいクライアントにおいてアカウントを作成し, 認可フローを開始することができる.
          攻撃者がアクセス許可のために認可サーバーに送られたとき, 正当なクライアントにより提供された認可URIを取得し, クライアントのリダイレクトURIを攻撃者の管理下にあるURIに交換する.
          攻撃者はその後, 正当なクライアントに向けた操作された認可アクセスリンクをたどるよう被害者を騙す.
          
        
</p>
<p>
          認可サーバーにおいて, 被害者は正当で信頼できるクライアントによる正常で有効なリクエストを促され, そのリクエストを認可する.
          被害者はその後, 認可コードとともに攻撃者の管理下にあるエンドポイントにリダイレクトされる.
          攻撃者は, クライアントにより提供されたオリジナルのリダイレクトURIを用いて,　認可コードを送ることにより認可フローを完了する.
          クライアントは認可コードとアクセストークンを交換し, それを攻撃者のクライアントのアカウントと紐づけることで, 被害者により(クライアント経由で)認可された保護されたリソースへのアクセス権を獲得できる.
          
        
</p>
<p>
          このような攻撃を防ぐため, 認可サーバーは認可コードの取得に用いたリダイレクトURIと, 認可コードとアクセストークンの交換時に提供されたリダイレクトURIが同一であることを確認しなければならない(MUST).
          認可サーバはpublicクライアントに対してリダイレクトURIの登録を要求しなければならず(MUST), confidencialクライアントに対してもリダイレクトURIの登録を要求すべきである(SHOULD).
          リダイレクトURIがリクエストにより提供されたとき, 認可サーバーは登録された値を用いてそれを検証しければならない(MUST).
          
        
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.7"></a><h3>10.7.&nbsp;
Resource Owner Password Credentials</h3>

<p>
          The resource owner password credentials grant type is often used for legacy or migration
          reasons. It reduces the overall risk of storing username and password by the client, but
          does not eliminate the need to expose highly privileged credentials to the client.
        
</p>
<p>
          This grant type carries a higher risk than other grant types because it maintains the
          password anti-pattern this protocol seeks to avoid. The client could abuse the password
          or the password could unintentionally be disclosed to an attacker (e.g. via log files or
          other records kept by the client).
        
</p>
<p>
          Additionally, because the resource owner does not have control over the authorization
          process (the resource owner involvement ends when it hands over its credentials to the
          client), the client can obtain access tokens with a broader scope and longer lifetime
          than desired by the resource owner. The authorization server should consider the scope
          and lifetime of access tokens issued via this grant type.
        
</p>
<p>
          The authorization server and client SHOULD minimize use of this grant type and utilize
          other grant types whenever possible.
        
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.8"></a><h3>10.8.&nbsp;
Request Confidentiality</h3>

<p>
          Access tokens, refresh tokens, resource owner passwords, and client credentials MUST NOT
          be transmitted in the clear. Authorization codes SHOULD NOT be transmitted in the clear.
        
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.9"></a><h3>10.9.&nbsp;
エンドポイントの真正性<!-- Endpoints Authenticity --></h3>

<p>
          man-in-the-middle アタックやフィッシングアタックを防ぐため, 認可サーバーは TLS を導入し, <a class='info' href='#RFC2818'>[RFC2818]<span> (</span><span class='info'>Rescorla, E., &ldquo;HTTP Over TLS,&rdquo; May&nbsp;2000.</span><span>)</span></a> に従って認可エンドポイントおよびトークンエンドポイントへのすべてのリクエストで TLS を利用したサーバー認証を必須としなければならない (MUST).
          クライアントはサーバー身元認証の要件に従って認可サーバーの TLS 証明書を検証しなければならない (MUST).
          
        
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.10"></a><h3>10.10.&nbsp;
クレデンシャルゲッシングアタック<!-- Credentials Guessing Attacks --></h3>

<p>
          認可サーバーは, アタッカーにアクセストークン, 認可コード, リフレッシュトークン, リソースオーナーパスワードおよびクライアントクレデンシャルを推測されないようにしなければならない (MUST).
          
        
</p>
<p>
          トークンやその他のクレデンシャルなど, エンドユーザーが直接扱うことのないクレデンシャルを生成する場合, 認可サーバーはゲッシングアタックのリスクを低減するため適切のエントロピーを確保しなければならない (MUST).
          エンドユーザーが扱うクレデンシャルについては, 認可サーバーはその他の保護対策を行わなければならない (MUST).
          
        
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.11"></a><h3>10.11.&nbsp;
フィッシングアタック<!-- Phishing Attacks --></h3>

<p>
          本仕様や類似プロトコルを実際に広く運用するにつれ, エンドユーザーはパスワード入力を求める Web サイトにリダイレクトされるという慣習になじんでゆくであろう.
          もしエンドユーザーがそういった Web サイトでパスワードを入力する際にそのサイトの真正性検証を怠った場合, この慣習がアタッカーに悪用され, リソースオーナーのパスワードを盗まれる可能性もある.
          
        
</p>
<p>
          サービスプロバイダーはエンドユーザーに対してフィッシングアタックにより引き起こされるリスクに関して教育し, エンドユーザーが簡単にサイトの真正性を確認できるメカニズムを提供するべきである.
          クライアントデベロッパーは, ユーザーエージェントとのインタラクション方式 (外部エージェント / 埋め込みエージェントのどちらを利用するかなど) とセキュリティーとの関係に加え, エンドユーザーによる認可サーバーの真正性検証能力についても熟考すべきである.
          
        
</p>
<p>
          フィッシングアタックのリスクを低減するため, 認可サーバーはエンドユーザーとのインタラクションを行うすべてのエンドポイントで TLS を利用しなければならない (MUST).
          
        
</p>
<a name="CSRF"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.12"></a><h3>10.12.&nbsp;
クロスサイトリクエストフォージェリ<!-- Cross-Site Request Forgery --></h3>

<p>
          クロスサイトリクエストフォージェリ (CSRF) は, 攻撃者が犠牲となるエンドユーザのユーザエージェントに (例えば, ユーザーエージェントに誤解を招きやすいリンクやイメージ, 転送によって) 悪意のあるURIを閲覧させることにより (通常, 有効なセッション・クッキーの存在によって) 信頼が確立されたサーバーへ接続させる手法です。
          
        
</p>
<p>
          クライアントの転送URIに対するCSRD攻撃は, 攻撃者が自身の認可コードやアクセストークンを紛れ込ませることを可能とし, 犠牲となるクライアントに自身の保護されたリソースではなく, 攻撃者のリソースに紐付いたアクセストークンを使わせることが出来てしまう (例えば, 犠牲者の銀行口座情報を攻撃者の管理しているリソースへ保存してしまう, といったことも可能となる).
          
        
</p>
<p>
          クライアントは自身の転送URIに対してCSRF保護対策を導入しなければならない (MUST). 一般的に保護対策は, 転送URIのエンドポイントへ送られたすべての要求に対して, 要求とユーザーエージェントの認証状態を紐付けるための値を含めることにより実現します (例えば, ユーザーエージェントを認証されるために使われるセッションクッキーのハッシュなど). クライアントは認可要求の発行時, この値を認可サーバへ伝搬するために <tt>state</tt> リクエストパラメーターを利用すべきである (SHOULD).
          
        
</p>
<p>
          Once authorization has been obtained from the end-user, the authorization server
          redirects the end-user's user-agent back to the client with the required binding value
          contained in the <tt>state</tt> parameter. The binding value enables
          the client to verify the validity of the request by matching the binding value to the
          user-agent's authenticated state. The binding value used for CSRF protection MUST contain
          a non-guessable value, and the user-agent's authenticated state (e.g. session cookie,
          HTML5 local storage) MUST be kept in a location accessible only to the client and the
          user-agent (i.e., protected by same-origin policy).
        
</p>
<p>
          A CSRF attack against the authorization server's authorization endpoint can result in an
          attacker obtaining end-user authorization for a malicious client without involving or
          alerting the end-user.
        
</p>
<p>
          The authorization server MUST implement CSRF protection for its authorization endpoint,
          and ensure that a malicious client cannot obtain authorization without the awareness and
          explicit consent of the resource owner.
        
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.13"></a><h3>10.13.&nbsp;
Clickjacking</h3>

<p>
          In a clickjacking attack, an attacker registers a legitimate client and then constructs a
          malicious site in which it loads the authorization server's authorization endpoint web
          page in a transparent iframe overlaid on top of a set of dummy buttons which are
          carefully constructed to be placed directly under important buttons on the authorization
          page. When an end-user clicks a misleading visible button, the end-user is actually
          clicking an invisible button on the authorization page (such as an "Authorize" button).
          This allows an attacker to trick a resource owner into granting its client access without
          their knowledge.
        
</p>
<p>
          To prevent this form of attack, native applications SHOULD use external browsers instead
          of embedding browsers in an iframe when requesting end-user authorization. For most newer
          browsers, avoidance of iframes can be enforced by the authorization server using the
          (non-standard) <tt>x-frame-options</tt> header. This header can have
          two values, <tt>deny</tt> and <tt>sameorigin</tt>,
          which will block any framing, or framing by sites with a different origin, respectively.
          For older browsers, javascript framebusting techniques can be used but may not be
          effective in all browsers.
        
</p>
<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.14"></a><h3>10.14.&nbsp;
Code Injection and Input Validation</h3>

<p>
          A code injection attack occurs when an input or otherwise external variable is used by an
          application unsanitized and causes modification to the application logic. This may allow
          an attacker to gain access to the application device or its data, cause denial of
          service, or a wide range of malicious side-effects.
        
</p>
<p>
          The Authorization server and client MUST validate and sanitize any value received, and in
          particular, the value of the <tt>state</tt> and
          <tt>redirect_uri</tt> parameters.
        
</p>
<a name="open-redirect"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10.15"></a><h3>10.15.&nbsp;
Open Redirectors</h3>

<p>
          The authorization server authorization endpoint and the client redirection endpoint can
          be improperly configured and operate as open redirectors. An open redirector is an
          endpoint using a parameter to automatically redirect a user-agent to the location
          specified by the parameter value without any validation.
        
</p>
<p>
          Open redirectors can be used in phishing attacks, or by an attacker to get end-users to
          visit malicious sites by making the URI's authority look like a familiar and trusted
          destination. In addition, if the authorization server allows the client to register only
          part of the redirection URI, an attacker can use an open redirector operated by the
          client to construct a redirection URI that will pass the authorization server validation
          but will send the authorization code or access token to an endpoint under the control of
          the attacker.
        
</p>
<a name="anchor54"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<a name="type-registry"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1"></a><h3>11.1.&nbsp;
The OAuth Access Token Type Registry</h3>

<p>
          This specification establishes the OAuth access token type registry.
        
</p>
<p>
          Access token types are registered on the advice of one or more Designated Experts
          (appointed by the IESG or their delegate), with a Specification Required (using
          terminology from <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>). However, to allow for the allocation of
          values prior to publication, the Designated Expert(s) may approve registration once they
          are satisfied that such a specification will be published.
        
</p>
<p>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for access token type: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        
</p>
<p>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        
</p>
<p>
          Decisions (or lack thereof) made by the Designated Expert(s) can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        
</p>
<p>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        
</p>
<a name="anchor55"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.1.1"></a><h3>11.1.1.&nbsp;
Registration Template</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Type name:</dt>
<dd>
                
                The name requested (e.g., "example").
              
</dd>
<dt>Additional Token Endpoint Response Parameters:</dt>
<dd>
                
                Additional response parameters returned together with the
                <tt>access_token</tt> parameter. New parameters MUST be
                separately registered in the OAuth parameters registry as described by
                <a class='info' href='#parameters-registry'>Section&nbsp;11.2<span> (</span><span class='info'>The OAuth Parameters Registry</span><span>)</span></a>.
              
</dd>
<dt>HTTP Authentication Scheme(s):</dt>
<dd>
                
                The HTTP authentication scheme name(s), if any, used to authenticate protected
                resources requests using access tokens of this type.
              
</dd>
<dt>Change controller:</dt>
<dd>
                
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              
</dd>
<dt>Specification document(s):</dt>
<dd>
                
                Reference to the document that specifies the parameter, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              
</dd>
</dl></blockquote><p>
          
</p>
<a name="parameters-registry"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2"></a><h3>11.2.&nbsp;
The OAuth Parameters Registry</h3>

<p>
          This specification establishes the OAuth parameters registry.
        
</p>
<p>
          Additional parameters for inclusion in the authorization endpoint request, the
          authorization endpoint response, the token endpoint request, or the token endpoint
          response are registered on the advice of one or more Designated Experts (appointed by
          the IESG or their delegate), with a Specification Required (using terminology from
          <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>). However, to allow for the allocation of values prior to
          publication, the Designated Expert(s) may approve registration once they are satisfied
          that such a specification will be published.
        
</p>
<p>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for parameter: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        
</p>
<p>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        
</p>
<p>
          Decisions (or lack thereof) made by the Designated Expert(s) can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        
</p>
<p>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        
</p>
<a name="anchor56"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2.1"></a><h3>11.2.1.&nbsp;
Registration Template</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Parameter name:</dt>
<dd>
                
                The name requested (e.g., "example").
              
</dd>
<dt>Parameter usage location:</dt>
<dd>
                
                The location(s) where parameter can be used. The possible locations are:
                authorization request, authorization response, token request, or token response.
              
</dd>
<dt>Change controller:</dt>
<dd>
                
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              
</dd>
<dt>Specification document(s):</dt>
<dd>
                
                Reference to the document that specifies the parameter, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              
</dd>
</dl></blockquote><p>
          
</p>
<a name="anchor57"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.2.2"></a><h3>11.2.2.&nbsp;
Initial Registry Contents</h3>

<p>
            The OAuth Parameters Registry's initial contents are:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: client_id
              
</li>
<li>
                Parameter usage location: authorization request, token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: client_secret
              
</li>
<li>
                Parameter usage location: token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: response_type
              
</li>
<li>
                Parameter usage location: authorization request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: redirect_uri
              
</li>
<li>
                Parameter usage location: authorization request, token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: scope
              
</li>
<li>
                Parameter usage location: authorization request, authorization response, token
                request, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: state
              
</li>
<li>
                Parameter usage location: authorization request, authorization response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: code
              
</li>
<li>
                Parameter usage location: authorization response, token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: error_description
              
</li>
<li>
                Parameter usage location: authorization response, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: error_uri
              
</li>
<li>
                Parameter usage location: authorization response, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: grant_type
              
</li>
<li>
                Parameter usage location: token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: access_token
              
</li>
<li>
                Parameter usage location: authorization response, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: token_type
              
</li>
<li>
                Parameter usage location: authorization response, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: expires_in
              
</li>
<li>
                Parameter usage location: authorization response, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: username
              
</li>
<li>
                Parameter usage location: token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: password
              
</li>
<li>
                Parameter usage location: token request
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Parameter name: refresh_token
              
</li>
<li>
                Parameter usage location: token request, token response
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<a name="response-type-registry"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3"></a><h3>11.3.&nbsp;
The OAuth Authorization Endpoint Response Type Registry</h3>

<p>
          This specification establishes the OAuth authorization endpoint response type registry.
        
</p>
<p>
          Additional response type for use with the authorization endpoint are registered on the
          advice of one or more Designated Experts (appointed by the IESG or their delegate), with
          a Specification Required (using terminology from <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>). However, to
          allow for the allocation of values prior to publication, the Designated Expert(s) may
          approve registration once they are satisfied that such a specification will be published.
        
</p>
<p>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for response type: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        
</p>
<p>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        
</p>
<p>
          Decisions (or lack thereof) made by the Designated Expert(s) can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        
</p>
<p>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        
</p>
<a name="anchor58"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3.1"></a><h3>11.3.1.&nbsp;
Registration Template</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Response type name:</dt>
<dd>
                
                The name requested (e.g., "example").
              
</dd>
<dt>Change controller:</dt>
<dd>
                
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              
</dd>
<dt>Specification document(s):</dt>
<dd>
                
                Reference to the document that specifies the type, preferably including a URI that
                can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              
</dd>
</dl></blockquote><p>
          
</p>
<a name="anchor59"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.3.2"></a><h3>11.3.2.&nbsp;
Initial Registry Contents</h3>

<p>
            The OAuth Authorization Endpoint Response Type Registry's initial contents are:
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Response type name: code
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<p>
            </p>
<ul class="text">
<li>
                Response type name: token
              
</li>
<li>
                Change controller: IETF
              
</li>
<li>
                Specification document(s): [[ this document ]]
              
</li>
</ul><p>
          
</p>
<a name="error-registry"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4"></a><h3>11.4.&nbsp;
The OAuth Extensions Error Registry</h3>

<p>
          This specification establishes the OAuth extensions error registry.
        
</p>
<p>
          Additional error codes used together with other protocol extensions (i.e. extension grant
          types, access token types, or extension parameters) are registered on the advice of one
          or more Designated Experts (appointed by the IESG or their delegate), with a
          Specification Required (using terminology from <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>). However, to
          allow for the allocation of values prior to publication, the Designated Expert(s) may
          approve registration once they are satisfied that such a specification will be published.
        
</p>
<p>
          Registration requests should be sent to the [TBD]@ietf.org mailing list for review and
          comment, with an appropriate subject (e.g., "Request for error code: example").
          [[ Note to RFC-EDITOR: The name of the mailing list should be determined in consultation
          with the IESG and IANA. Suggested name: oauth-ext-review. ]]
        
</p>
<p>
          Within at most 14 days of the request, the Designated Expert(s) will either approve or
          deny the registration request, communicating this decision to the review list and IANA.
          Denials should include an explanation and, if applicable, suggestions as to how to make
          the request successful.
        
</p>
<p>
          Decisions (or lack thereof) made by the Designated Expert(s) can be first appealed to
          Application Area Directors (contactable using app-ads@tools.ietf.org email address or
          directly by looking up their email addresses on http://www.iesg.org/ website) and, if the
          appellant is not satisfied with the response, to the full IESG (using the iesg@iesg.org
          mailing list).
        
</p>
<p>
          IANA should only accept registry updates from the Designated Expert(s), and should direct
          all requests for registration to the review mailing list.
        
</p>
<a name="anchor60"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11.4.1"></a><h3>11.4.1.&nbsp;
Registration Template</h3>

<p>
            </p>
<blockquote class="text"><dl>
<dt>Error name:</dt>
<dd>
                
                The name requested (e.g., "example").
              
</dd>
<dt>Error usage location:</dt>
<dd>
                
                The location(s) where the error can be used. The possible locations are:
                authorization code grant error response (<a class='info' href='#code-authz-error'>Section&nbsp;4.1.2.1<span> (</span><span class='info'>Error Response</span><span>)</span></a>),
                implicit grant error response (<a class='info' href='#implicit-authz-error'>Section&nbsp;4.2.2.1<span> (</span><span class='info'>Error Response</span><span>)</span></a>), or token
                error response (<a class='info' href='#token-errors'>Section&nbsp;5.2<span> (</span><span class='info'>エラーレスポンス<!-- Error Response --></span><span>)</span></a>).
              
</dd>
<dt>Related protocol extension:</dt>
<dd>
                
                The name of the extension grant type, access token type, or extension parameter,
                the error code is used in conjunction with.
              
</dd>
<dt>Change controller:</dt>
<dd>
                
                For standards-track RFCs, state "IETF". For others, give the name of the
                responsible party. Other details (e.g., postal address, e-mail address, home page
                URI) may also be included.
              
</dd>
<dt>Specification document(s):</dt>
<dd>
                
                Reference to the document that specifies the error code, preferably including a URI
                that can be used to retrieve a copy of the document. An indication of the relevant
                sections may also be included, but is not required.
              
</dd>
</dl></blockquote><p>
          
</p>
<a name="anchor61"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgements</h3>

<p>
        The initial OAuth 2.0 protocol specification was edited by David Recordon, based on two
        previous publications: the OAuth 1.0 community specification <a class='info' href='#RFC5849'>[RFC5849]<span> (</span><span class='info'>Hammer-Lahav, E., &ldquo;The OAuth 1.0 Protocol,&rdquo; April&nbsp;2010.</span><span>)</span></a>, and
        OAuth WRAP (OAuth Web Resource Authorization Profiles)
        <a class='info' href='#I-D.draft-hardt-oauth-01'>[I&#8209;D.draft&#8209;hardt&#8209;oauth&#8209;01]<span> (</span><span class='info'>Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, &ldquo;OAuth Web Resource Authorization Profiles,&rdquo; January&nbsp;2010.</span><span>)</span></a>. The Security Considerations section was drafted
        by Torsten Lodderstedt, Mark McGloin, Phil Hunt, and Anthony Nadalin.
      
</p>
<p>
        The OAuth 1.0 community specification was edited by Eran Hammer-Lahav and authored by
        Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M. Conlan, Blaine Cook, Leah Culver,
        Breno de Medeiros, Brian Eaton, Kellan Elliott-McCrea, Larry Halff, Eran Hammer-Lahav,
        Ben Laurie, Chris Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,
        Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.
      
</p>
<p>
        The OAuth WRAP specification was edited by Dick Hardt and authored by Brian Eaton,
        Yaron Goland, Dick Hardt, and Allen Tom.
      
</p>
<p>
        This specification is the work of the OAuth Working Group which includes dozens of active
        and dedicated participants. In particular, the following individuals contributed ideas,
        feedback, and wording which shaped and formed the final specification:
      
</p>
<p>
        Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden Bell, Scott Cantor, Marcos Caceres, Blaine Cook, Brian Campbell,
        Brian Eaton, Leah Culver, Bill de hOra, Andre DeMarre, Brian Eaton, Brian Ellin, Igor Faynberg,
        George Fletcher, Tim Freeman, Evan Gilbert, Yaron Goland, Brent Goldman,
        Kristoffer Gronowski, Justin Hart, Dick Hardt, Craig Heath, Phil Hunt, Michael B. Jones,
        John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara, Rasmus Lerdorf, Torsten Lodderstedt,
        Hui-Lan Lu, Casey Lucas, Paul Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,
        Laurence Miao, Chuck Mortimore, Anthony Nadalin, Justin Richer, Peter Saint-Andre,
        Nat Sakimura, Rob Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,
        Justin Smith, Niv Steingarten, Christian Stubner, Jeremy Suriel, Paul Tarjan, Allen Tom, Franklin Tse,
        Nick Walker, Shane Weeden, and Skylar Woodward.
      
</p>
<a name="anchor62"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Editor's Notes</h3>

<p>
        While many people contributed to this specification throughout its long journey, the editor
        would like to acknowledge and thank a few individuals for their outstanding and invaluable
        efforts leading up to the publication of this specification. It is these individuals without
        whom this work would not have existed or reached its successful conclusion.
      
</p>
<p>
        David Recordon for continuously being one of OAuth’s most valuable assets, bringing
        pragmatism and urgency to the work, and helping shape it from its very beginning, as well
        as being one of the best collaborators I had the pleasure of working with.
      
</p>
<p>
        Mark Nottingham for introducing OAuth to the IETF and setting the community on this course.
        Lisa Dusseault for her support and guidance as the Application area director. Blaine Cook,
        Peter Saint-Andre, and Hannes Tschofenig for their work as working group chairs.
      
</p>
<p>
        James Manger for his creative ideas and always insightful feedback. Brian Campbell,
        Torsten Lodderstedt, Chuck Mortimore, Justin Richer, Marius Scurtescu, and Luke Shepard for
        their continued participation and valuable feedback.
      
</p>
<p>
        Special thanks goes to Mike Curtis and Yahoo! for their unconditional support of this work
        for over three years.
      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2246">[RFC2246]</a></td>
<td class="author-text"><a href="mailto:tdierks@certicom.com">Dierks, T.</a> and <a href="mailto:callen@certicom.com">C. Allen</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>,&rdquo; RFC&nbsp;2246, January&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2617">[RFC2617]</a></td>
<td class="author-text"><a href="mailto:john@math.nwu.edu">Franks, J.</a>, <a href="mailto:pbaker@verisign.com">Hallam-Baker, P.</a>, <a href="mailto:jeff@AbiSource.com">Hostetler, J.</a>, <a href="mailto:lawrence@agranat.com">Lawrence, S.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, Luotonen, A., and <a href="mailto:stewart@OpenMarket.com">L. Stewart</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>,&rdquo; RFC&nbsp;2617, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2617.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2617.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2617.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2818">[RFC2818]</a></td>
<td class="author-text">Rescorla, E., &ldquo;<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>,&rdquo; RFC&nbsp;2818, May&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2818.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4627">[RFC4627]</a></td>
<td class="author-text">Crockford, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>,&rdquo; RFC&nbsp;4627, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4949">[RFC4949]</a></td>
<td class="author-text">Shirey, R., &ldquo;<a href="http://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>,&rdquo; RFC&nbsp;4949, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4949.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5234">[RFC5234]</a></td>
<td class="author-text">Crocker, D. and P. Overell, &ldquo;<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5234.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="W3C.REC-html401-19991224">[W3C.REC-html401-19991224]</a></td>
<td class="author-text">Raggett, D., Jacobs, I., and A. Hors, &ldquo;<a href="http://www.w3.org/TR/1999/REC-html401-19991224">HTML 4.01 Specification</a>,&rdquo; World Wide Web Consortium Recommendation&nbsp;REC-html401-19991224, December&nbsp;1999 (<a href="http://www.w3.org/TR/1999/REC-html401-19991224">HTML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.draft-hardt-oauth-01">[I-D.draft-hardt-oauth-01]</a></td>
<td class="author-text">Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-hardt-oauth-01.txt">OAuth Web Resource Authorization Profiles</a>,&rdquo; January&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-oauth-saml2-bearer">[I-D.ietf-oauth-saml2-bearer]</a></td>
<td class="author-text">Mortimore, C., &ldquo;<a href="http://tools.ietf.org/html/draft-ietf-oauth-saml2-bearer-08">SAML 2.0 Bearer Assertion Profiles for OAuth 2.0</a>,&rdquo; draft-ietf-oauth-saml2-bearer-08 (work in progress), August&nbsp;2011 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-saml2-bearer-08.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-oauth-v2-bearer">[I-D.ietf-oauth-v2-bearer]</a></td>
<td class="author-text">Jones, M., Hardt, D., and D. Recordon, &ldquo;<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer-08">The OAuth 2.0 Protocol: Bearer Tokens</a>,&rdquo; draft-ietf-oauth-v2-bearer-08 (work in progress), July&nbsp;2011 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-v2-bearer-08.txt">TXT</a>, <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-v2-bearer-08.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-oauth-v2-http-mac">[I-D.ietf-oauth-v2-http-mac]</a></td>
<td class="author-text">Hammer-Lahav, E., Barth, A., and B. Adida, &ldquo;<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-00">HTTP Authentication: MAC Access Authentication</a>,&rdquo; draft-ietf-oauth-v2-http-mac-00 (work in progress), May&nbsp;2011 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-v2-http-mac-00.txt">TXT</a>, <a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-v2-http-mac-00.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-oauth-v2-threatmodel">[I-D.ietf-oauth-v2-threatmodel]</a></td>
<td class="author-text">Lodderstedt, T., McGloin, M., and P. Hunt, &ldquo;<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-threatmodel-00">OAuth 2.0 Threat Model and Security Considerations</a>,&rdquo; draft-ietf-oauth-v2-threatmodel-00 (work in progress), July&nbsp;2011 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-oauth-v2-threatmodel-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="OASIS.saml-core-2.0-os">[OASIS.saml-core-2.0-os]</a></td>
<td class="author-text"><a href="mailto:cantor.2@osu.edu">Cantor, S.</a>, <a href="mailto:John.Kemp@nokia.com">Kemp, J.</a>, <a href="mailto:rphilpott@rsasecurity.com">Philpott, R.</a>, and <a href="mailto:eve.maler@sun.com">E. Maler</a>, &ldquo;<a href="http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">Assertions and Protocol for the OASIS Security Assertion Markup Language
            (SAML) V2.0</a>,&rdquo; OASIS Standard&nbsp;saml-core-2.0-os, March&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5849">[RFC5849]</a></td>
<td class="author-text">Hammer-Lahav, E., &ldquo;<a href="http://tools.ietf.org/html/rfc5849">The OAuth 1.0 Protocol</a>,&rdquo; RFC&nbsp;5849, April&nbsp;2010 (<a href="http://www.rfc-editor.org/rfc/rfc5849.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Eran Hammer-Lahav (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yahoo!</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:eran@hueniverse.com">eran@hueniverse.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://hueniverse.com">http://hueniverse.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">David Recordon</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Facebook</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dr@fb.com">dr@fb.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.davidrecordon.com/">http://www.davidrecordon.com/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dick Hardt</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:dick.hardt@gmail.com">dick.hardt@gmail.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://dickhardt.org/">http://dickhardt.org/</a></td></tr>
</table>
</body></html>
